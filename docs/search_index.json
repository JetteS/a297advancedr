[
["performance.html", "Chapter 5 Performance 5.1 R’s memory management 5.2 Early advice 5.3 Vectorization 5.4 Algorithms &amp; data structures 5.5 Rcpp 5.6 Linear algebra 5.7 Exercises 5.8 Parallel", " Chapter 5 Performance Some resources used here or for further reading: Advanced R Efficient R programming The people who say that “R is just always slow” are usually not great R programmers. It is true that writing inefficient R code is easy, yet writing efficient R code is also possible when you know what you’re doing. In this chapter, you will learn how to write R(cpp) code that is fast. 5.1 R’s memory management See this new chapter of Advanced R. 5.2 Early advice 5.2.1 NEVER GROW A VECTOR Example computing the cumulative sums of a vector: x &lt;- rnorm(1e4) # Try also with n = 1e5 system.time({ current_sum &lt;- 0 res &lt;- c() for (x_i in x) { current_sum &lt;- current_sum + x_i res &lt;- c(res, current_sum) } }) #&gt; user system elapsed #&gt; 0.160 0.000 0.162 Here, at each iteration, you reallocating a vector (of increasing size). Allocation of memory takes time as well as computations. This makes your code quadratic with the size of x (if you multiply the size of x by 2, you can expect the execution time to be multiplied by 4, for large sample sizes), whereas it should be only linear. A good solution is to always pre-allocate your results (if you know the size): system.time({ current_sum &lt;- 0 res2 &lt;- double(length(x)) for (i in seq_along(x)) { current_sum &lt;- current_sum + x[i] res2[i] &lt;- current_sum } }) #&gt; user system elapsed #&gt; 0.004 0.000 0.002 all.equal(res2, res) #&gt; [1] TRUE If you don’t know the size of the results, you can store them in a list and merge them afterwards: system.time({ current_sum &lt;- 0 res3 &lt;- list() for (i in seq_along(x)) { current_sum &lt;- current_sum + x[i] res3[[i]] &lt;- current_sum } }) #&gt; user system elapsed #&gt; 0.004 0.000 0.005 all.equal(unlist(res3), res) #&gt; [1] TRUE With recent versions of R (&gt;= 3.4), you can efficiently grow a vector using system.time({ current_sum &lt;- 0 res4 &lt;- c() for (i in seq_along(x)) { current_sum &lt;- current_sum + x[i] res4[i] &lt;- current_sum } }) #&gt; user system elapsed #&gt; 0.004 0.000 0.005 all.equal(res4, res) #&gt; [1] TRUE Assigning to an element of a vector beyond the current length now over-allocates by a small fraction. The new vector is marked internally as growable, and the true length of the new vector is stored in the truelength field. This makes building up a vector result by assigning to the next element beyond the current length more efficient, though pre-allocating is still preferred. The implementation is subject to change and not intended to be used in packages at this time. (NEWS) An even better solution would be to avoid the loop by using a vectorized function: system.time(res5 &lt;- cumsum(x)) #&gt; user system elapsed #&gt; 0 0 0 all.equal(res5, res) #&gt; [1] TRUE x &lt;- rnorm(1e7) system.time(cumsum(x)) #&gt; user system elapsed #&gt; 0.040 0.008 0.050 As a second example, let us generate a matrix of uniform values (max changing for every column): n &lt;- 1e3 max &lt;- 1:1000 system.time({ mat &lt;- NULL for (m in max) { mat &lt;- cbind(mat, runif(n, max = m)) } }) #&gt; user system elapsed #&gt; 0.540 0.040 0.582 apply(mat, 2, max)[1:10] #&gt; [1] 0.9992733 1.9975855 2.9943939 3.9985295 4.9853001 5.9989464 6.9827442 7.9856026 #&gt; [9] 8.9811166 9.9901440 So, we can either pre-allocate a list or a matrix: system.time({ l &lt;- vector(&quot;list&quot;, length(max)) for (i in seq_along(max)) { l[[i]] &lt;- runif(n, max = max[i]) } mat2 &lt;- do.call(&quot;cbind&quot;, l) }) #&gt; user system elapsed #&gt; 0.028 0.000 0.029 apply(mat2, 2, max)[1:10] #&gt; [1] 0.9994997 1.9945268 2.9996468 3.9993043 4.9989702 5.9959175 6.9989815 7.9860012 #&gt; [9] 8.9951936 9.9894661 system.time({ mat3 &lt;- matrix(0, n, length(max)) for (i in seq_along(max)) { mat3[, i] &lt;- runif(n, max = max[i]) } }) #&gt; user system elapsed #&gt; 0.028 0.000 0.029 apply(mat3, 2, max)[1:10] #&gt; [1] 0.9991321 1.9996290 2.9998566 3.9933106 4.9990299 5.9648767 6.9962876 7.9891011 #&gt; [9] 8.9913810 9.9998873 What is nice with using a list is that you don’t need to pre-allocate. Indeed, as opposed to atomic vectors, each element of a list is in different places in memory so that you don’t have to reallocate all the data when you add an element to a list. system.time({ l &lt;- list() for (i in seq_along(max)) { l[[i]] &lt;- runif(n, max = max[i]) } mat4 &lt;- do.call(&quot;cbind&quot;, l) }) #&gt; user system elapsed #&gt; 0.028 0.000 0.028 apply(mat4, 2, max)[1:10] #&gt; [1] 0.9994213 1.9986288 2.9989776 3.9971426 4.9944155 5.9791485 6.9937155 7.9907919 #&gt; [9] 8.9973582 9.9760254 Instead of pre-allocating yourself, you can use sapply (or lapply and calling do.call() after, as previously done): system.time( mat4 &lt;- sapply(max, function(m) runif(n, max = m)) ) #&gt; user system elapsed #&gt; 0.028 0.000 0.029 apply(mat4, 2, max)[1:10] #&gt; [1] 0.9980504 1.9971051 2.9940374 3.9984231 4.9893505 5.9992387 6.9958400 7.9978336 #&gt; [9] 8.9902405 9.9976314 Don’t listen to people telling you that sapply() is a vectorized operation that is so much faster than loops. 5.2.2 Access columns of a matrix When you do computations on a matrix, recall that a matrix is just a vector with some dimensions. vec &lt;- 1:20 dim(vec) &lt;- c(4, 5) vec #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] 1 5 9 13 17 #&gt; [2,] 2 6 10 14 18 #&gt; [3,] 3 7 11 15 19 #&gt; [4,] 4 8 12 16 20 So, as you can see in this example, R matrices are column-oriented, which means that elements of the same column are stored contiguously in memory. Therefore, accessing elements of the same column is fast. 5.2.3 Use the right function Often, in order to optimize your code, you can simply find the right function to do what you need to do. For example, using rowMeans(x) instead of apply(x, 1, mean) can save you a lot of time. For example, if you want more efficient functions that apply to rows and columns of matrices, you can check package {matrixStats}. Another example is when reading large text files; in such cases, prefer using data.table::fread() rather than read.table(). Generally, packages that uses C/Rcpp are efficient. 5.2.4 Do not try to optimize everything “Programmers waste enormous amounts of time thinking about, or worrying about, the speed of noncritical parts of their programs, and these attempts at efficiency actually have a strong negative impact when debugging and maintenance are considered.” — Donald Knuth. If you try to optimize each and every part of your code, you will end up losing a lot of time writing it and it will probably less readable. R is great at prototyping quickly because you can write code in a concise and easy way. Begin by doing just that. If performance matters, then profile your code to see which part of your code is taking too much time and optimize only this part! Learn more on how to profile your code in RStudio in this article. 5.3 Vectorization See this great blog post by Noam Ross to understand vectorization. 5.3.1 Exercise Monte-Carlo integration (example from book Efficient R programming) Suppose we wish to estimate the integral \\(\\int_0^1 x^2 dx\\) using a Monte-Carlo method. Essentially, we throw darts at the curve and count the number of darts that fall below the curve (as in the following figure). Monte Carlo Integration pseudo-code Initialize: hits = 0 for i in 1:N \\(~~\\) Generate two random numbers, \\(U_1\\) and \\(U_2\\), between 0 and 1 \\(~~\\) If \\(U_2 &lt; U_1^2\\), then hits = hits + 1 end for Area estimate = hits / N Naively implementing this Monte-Carlo algorithm in R would typically lead to something like: monte_carlo &lt;- function(N) { hits &lt;- 0 for (i in seq_len(N)) { u1 &lt;- runif(1) u2 &lt;- runif(1) if (u1 ^ 2 &gt; u2) { hits &lt;- hits + 1 } } hits / N } This takes a few seconds for N = 1e6: N &lt;- 1e6 system.time(monte_carlo(N)) #&gt; user system elapsed #&gt; 2.500 0.008 2.512 Your task: Find a vectorized solution for this problem: system.time(monte_carlo_vec(N)) #&gt; user system elapsed #&gt; 0.048 0.000 0.049 5.4 Algorithms &amp; data structures Sometimes, getting the right data structure (e.g. using a matrix instead of a data frame or integers instead of characters) can save you some computation time. Is your algorithm doing some redundant computations making it e.g. quadratic instead of linear with respect to the dimension of your data? See exercises (section 5.7) for some insights. You can also find a detailed example in this blog post. 5.5 Rcpp See this presentation. You have this data and this working code (a loop) that is slow mydf &lt;- readRDS(system.file(&quot;extdata/one-million.rds&quot;, package = &quot;advr38pkg&quot;)) QRA_3Dmatrix &lt;- array(0, dim = c(max(mydf$ID), max(mydf$Volume), 2)) for (i in seq_len(nrow(mydf))) { # Row corresponds to IDcell row &lt;- mydf[[i, 1]] # Column corresponds to the volume class column &lt;- mydf[[i, 3]] # Number of events, initially zero, then +1 QRA_3Dmatrix[row, column, 1] &lt;- QRA_3Dmatrix[row, column, 1] + 1 # Sum energy QRA_3Dmatrix[row, column, 2] &lt;- QRA_3Dmatrix[row, column, 2] + 1 - 1.358 / (1 + exp( (1000 * mydf[[i, 2]] - 129000) / 120300 )) } Rewrite this for-loop with Rcpp. You can also try to use {dplyr} for this problem. 5.6 Linear algebra In R, prefer using crossprod(X) and tcrossprod(X) instead of t(X) %*% X and X %*% t(X). Also using A %*% (B %*% y) and solve(A, y) will be faster than A %*% B %*% y and solve(A) %*% y. Don’t re-implement linear algebra operations (such as matrix products) yourself. There exist some highly optimized libraries for this. If you want to use linear algebra in Rcpp, try RcppArmadillo or RcppEigen. If you want to use some optimized multi-threaded linear library, you can try Microsoft R Open. 5.6.1 Exercise Rewrite this problem to use linear algebra instead of a loop: N &lt;- 1e5 x &lt;- rnorm(N*3*3); dim(x) &lt;- c(N,3,3) y &lt;- rnorm(N*3*3); dim(y) &lt;- c(N,3,3) system.time({ gg &lt;- 0 for (n in 1:dim(x)[1]){ gg &lt;- gg + t(x[n,,]) %*% y[n,,] } }) #&gt; user system elapsed #&gt; 0.448 0.000 0.448 A possible faster solution takes #&gt; user system elapsed #&gt; 0.004 0.000 0.004 5.7 Exercises Generate \\(10^8\\) (begin with \\(10^4\\)) steps of the process described by the formula:\\[X(0)=0\\]\\[X(t+1)=X(t)+Y(t)\\] where \\(Y(t)\\) are independent random variables with the distribution \\(N(0,1)\\). Then, calculate in what percentage of indices \\(t\\) the value of \\(X(t)\\) was negative. You don’t need to store values of \\(X\\) if you don’t want to. What would be the benefit of writing an Rcpp function over a simple vectorized R function? set.seed(1) system.time(p &lt;- advr38pkg::random_walk_neg_prop(1e7)) #&gt; user system elapsed #&gt; 0.384 0.000 0.383 p #&gt; [1] 0.3400444 mat &lt;- as.matrix(mtcars) ind &lt;- seq_len(nrow(mat)) mat_big &lt;- mat[rep(ind, 1000), ] ## 1000 times bigger dataset last_row &lt;- mat_big[nrow(mat_big), ] Speed up these loops: system.time({ for (j in 1:ncol(mat_big)) { for (i in 1:nrow(mat_big)) { mat_big[i, j] &lt;- 10 * mat_big[i, j] * last_row[j] } } }) #&gt; user system elapsed #&gt; 0.404 0.000 0.404 Why colSums() on a whole matrix is faster than on only half of it? m0 &lt;- matrix(rnorm(1e6), 1e3, 1e3) microbenchmark::microbenchmark( colSums(m0[, 1:500]), colSums(m0) ) #&gt; Unit: microseconds #&gt; expr min lq mean median uq max neval #&gt; colSums(m0[, 1:500]) 2352.925 2460.486 2740.3984 2544.067 2729.5235 5827.981 100 #&gt; colSums(m0) 787.114 797.581 830.4224 825.338 860.1075 925.877 100 Try to speed up this code by vectorizing it first. Then, recode it in Rcpp and benchmark all the solutions you came up with. M &lt;- 50 step1 &lt;- runif(M) A &lt;- rnorm(M) N &lt;- 1e4 tau &lt;- matrix(0, N + 1, M) tau[1, ] &lt;- A for (j in 1:M) { for (i in 2:nrow(tau)) { tau[i, j] &lt;- tau[i - 1, j] + step1[j] * 1.0025^(i - 2) } } Make a fast function that counts the number of elements between a sequence of breaks. Can you do it in base R? Try also implementing it in Rcpp. How can you implement a solution whose computation time doesn’t depend on the number of breaks? [Which are the special cases that you should consider?] x &lt;- sample(10, size = 1e4, replace = TRUE) breaks &lt;- c(1, 3, 9, 9.5, 10) table(cut(x, breaks)) #&gt; #&gt; (1,3] (3,9] (9,9.5] (9.5,10] #&gt; 2082 5925 0 994 hist(x, breaks, plot = FALSE)$counts # includes first break #&gt; [1] 3081 5925 0 994 advr38pkg::count_by_breaks(x, breaks) #&gt; [1] 2082 5925 0 994 advr38pkg::count_by_breaks_fast(x, breaks) #&gt; [1] 2082 5925 0 994 microbenchmark::microbenchmark( table(cut(x, breaks)), hist(x, breaks, plot = FALSE)$counts, advr38pkg::count_by_breaks(x, breaks), advr38pkg::count_by_breaks_fast(x, breaks) ) #&gt; Unit: microseconds #&gt; expr min lq mean median #&gt; table(cut(x, breaks)) 1939.305 1992.8890 2056.5053 2052.708 #&gt; hist(x, breaks, plot = FALSE)$counts 296.459 307.2925 328.2214 316.400 #&gt; advr38pkg::count_by_breaks(x, breaks) 250.942 263.3065 319.8725 277.352 #&gt; advr38pkg::count_by_breaks_fast(x, breaks) 151.577 163.8285 177.7793 168.628 #&gt; uq max neval #&gt; 2092.5025 3218.879 100 #&gt; 354.5790 397.192 100 #&gt; 409.4430 451.420 100 #&gt; 196.7695 222.926 100 x2 &lt;- sample(10, size = 1e5, replace = TRUE) breaks2 &lt;- seq(0, 10, length.out = 100) microbenchmark::microbenchmark( advr38pkg::count_by_breaks(x2, breaks), advr38pkg::count_by_breaks_fast(x2, breaks), advr38pkg::count_by_breaks(x2, breaks2), advr38pkg::count_by_breaks_fast(x2, breaks2) ) #&gt; Unit: milliseconds #&gt; expr min lq mean median #&gt; advr38pkg::count_by_breaks(x2, breaks) 2.206192 2.240911 2.294838 2.264220 #&gt; advr38pkg::count_by_breaks_fast(x2, breaks) 1.200073 1.215027 1.256914 1.241628 #&gt; advr38pkg::count_by_breaks(x2, breaks2) 52.479036 88.253144 88.883374 88.553685 #&gt; advr38pkg::count_by_breaks_fast(x2, breaks2) 1.227186 1.256834 1.299580 1.290217 #&gt; uq max neval #&gt; 2.301622 3.197627 100 #&gt; 1.288435 1.608792 100 #&gt; 89.086285 126.321388 100 #&gt; 1.315935 2.201534 100 An R user wants to implement some sampling on a sparse matrix and provides this working code: library(Matrix) N &lt;- 100 m &lt;- Matrix(0, nrow = N, ncol = N) for (j in 1:N) { cols &lt;- sample((1:N)[-j], 2) # 2 columns != j m[j, cols] &lt;- 1 } This code is slow; can you find two major reasons why? How can you more efficiently assign 1s? Can you use sampling with replacement (which can be easily vectorized) in this example? Implement faster solutions in R and Rcpp. Make a fast function that returns all prime numbers up to a number N. N &lt;- 1e6 system.time( primes &lt;- advr38pkg::AllPrimesUpTo(N) ) #&gt; user system elapsed #&gt; 0.032 0.000 0.032 plot(primes, pch = 20, cex = 0.5) Imagine you have a list of animals, which are infected by other individuals: # Make some data allanimals &lt;- data.frame( AnimalID = c(&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;, &quot;a4&quot;, &quot;a5&quot;, &quot;a6&quot;, &quot;a7&quot;, &quot;a8&quot;, &quot;b1&quot;, &quot;b2&quot;, &quot;b3&quot;, &quot;b4&quot;, &quot;b5&quot;, &quot;c1&quot;, &quot;c2&quot;, &quot;c3&quot;, &quot;c4&quot;, &quot;d1&quot;, &quot;d2&quot;, &quot;e1&quot;, &quot;e2&quot;, &quot;e3&quot;, &quot;e4&quot;, &quot;e5&quot;, &quot;e6&quot;, &quot;f1&quot;, &quot;f2&quot;, &quot;f3&quot;, &quot;f4&quot;, &quot;f5&quot;, &quot;f6&quot;, &quot;f7&quot;), InfectingAnimal = c(NA, &quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;, &quot;a4&quot;, &quot;a5&quot;, &quot;a6&quot;, &quot;a7&quot;, &quot;a2&quot;, &quot;b1&quot;, &quot;b2&quot;, &quot;b3&quot;, &quot;b4&quot;, &quot;b3&quot;, &quot;c1&quot;, &quot;c2&quot;, &quot;c3&quot;, &quot;c3&quot;, &quot;d1&quot;, &quot;b1&quot;, &quot;e1&quot;, &quot;e2&quot;, &quot;e3&quot;, &quot;e4&quot;, &quot;e5&quot;, &quot;e1&quot;, &quot;f1&quot;, &quot;f2&quot;, &quot;f3&quot;, &quot;f4&quot;, &quot;f5&quot;, &quot;f6&quot;), habitat = c(1L, 2L, 1L, 2L, 2L, 1L, 3L, 2L, 4L, 5L, 6L, 1L, 2L, 3L, 2L, 3L, 2L, 1L, 1L, 2L, 5L, 4L, 1L, 1L, 1L, 1L, 4L, 5L, 4L, 5L, 4L, 3L), stringsAsFactors = FALSE ) # Check it out DT::datatable(allanimals) For a given animal (1), you want to get which animal (2) infected (1), and then which animal infected (2), and so on you want to get the whole path of infection. For example for animal d2, you want to return: #&gt; AnimalID InfectingAnimal habitat #&gt; 19 d2 d1 1 #&gt; 18 d1 c3 1 #&gt; 16 c3 c2 3 #&gt; 15 c2 c1 2 #&gt; 14 c1 b3 3 #&gt; 11 b3 b2 6 #&gt; 10 b2 b1 5 #&gt; 9 b1 a2 4 #&gt; 2 a2 a1 2 #&gt; 1 a1 &lt;NA&gt; 1 Find an efficient solution to this problem so that your solution could be used for a large dataset. Find a fast method to compute pairwise distances between 2 matrices. A naive R function would be: naive_pdist &lt;- function(A, B) { # A: matrix with observation vectors (nrow = number of observations) # B: matrix with another set of vectors (e.g. cluster centers) result = matrix(ncol = nrow(B), nrow = nrow(A)) for (i in 1:nrow(A)) for (j in 1:nrow(B)) result[i,j] = sqrt(sum( (A[i,] - B[j,])^2 )) result } To see a comparison of different computation strategies, see this nice blog post. 5.8 Parallel I basically always use foreach and recommend to do so. See my guide to parallelism in R with foreach. Just remember to optimize your code before trying to parallelize it. Try to parallelize some of your best solutions for the previous exercises. "]
]
