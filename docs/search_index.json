[["performance.html", "Chapter 5 Performance 5.1 R’s memory management 5.2 Early advice 5.3 Vectorization 5.4 Rcpp 5.5 Linear algebra 5.6 Algorithms &amp; data structures 5.7 Exercises 5.8 Parallel computing", " Chapter 5 Performance Some resources used here or for further reading: Advanced R Efficient R programming The people who say that “R is just always slow” are usually not great R programmers. It is true that writing inefficient R code is easy, yet writing efficient R code is also possible when you know what you’re doing. In this chapter, you will learn how to write R(cpp) code that is fast. 5.1 R’s memory management Read more with this chapter of Advanced R. 5.1.1 Understanding binding basics x &lt;- c(1, 2, 3) It’s creating an object, a vector of values, c(1, 2, 3). And it’s binding that object to a name, x. y &lt;- x There are now two names for the same object in memory. 5.1.2 Copy-on-modify x &lt;- c(1, 2, 3) y &lt;- x y[3] &lt;- 4 x #&gt; [1] 1 2 3 The object in memory is copied before being modified, so that x is not modified. 5.1.3 Copy-on-modify: what about inside functions? f &lt;- function(a) { a } x &lt;- c(1, 2, 3) z &lt;- f(x) f2 &lt;- function(a) { a[1] &lt;- 10 a } z2 &lt;- f2(x) cbind(x, z2) #&gt; x z2 #&gt; [1,] 1 10 #&gt; [2,] 2 2 #&gt; [3,] 3 3 The input parameter is not modified; you operate on a local copy of a = x in f2(). 5.1.4 Lists It’s not just names (i.e. variables) that point to values; elements of lists do too. l1 &lt;- list(1, 2, 3) l2 &lt;- l1 5.1.5 Copy-on-modify for lists? l2[[3]] &lt;- 4 Only the third element needs to be copied. 5.1.6 Data frames Data frames are lists of vectors. d1 &lt;- data.frame(x = c(1, 5, 6), y = c(2, 4, 3)) d2 &lt;- d1 d2[, 2] &lt;- d2[, 2] * 2 # modify one column d3 &lt;- d1 d3[1, ] &lt;- d3[1, ] * 3 # modify one row By modifying the first row, you’re modifying the first element of all vectors, therefore the full data frame is copied.. 5.2 Early advice 5.2.1 NEVER GROW A VECTOR Example computing the cumulative sums of a vector: x &lt;- rnorm(2e4) # Try also with n = 1e5 system.time({ current_sum &lt;- 0 res &lt;- c() for (x_i in x) { current_sum &lt;- current_sum + x_i res &lt;- c(res, current_sum) } }) #&gt; user system elapsed #&gt; 0.54 0.45 1.00 Here, at each iteration, you are reallocating a vector (of increasing size). Not only computations take time, memory allocations do too. This makes your code quadratic with the size of x (if you multiply the size of x by 2, you can expect the execution time to be multiplied by 4, for large sample sizes), whereas it should be only linear. What happens is similar to if you would like to climb these stairs, you climb one stair, go to the bottom, then climb two stairs, go to bottom, climb three, and so on. That takes way more time than just climbing all stairs at once. A good solution is to always pre-allocate your results (if you know the size): system.time({ current_sum &lt;- 0 res2 &lt;- double(length(x)) for (i in seq_along(x)) { current_sum &lt;- current_sum + x[i] res2[i] &lt;- current_sum } }) #&gt; user system elapsed #&gt; 0.02 0.00 0.02 all.equal(res2, res) #&gt; [1] TRUE If you don’t know the size of the results, you can store them in a list and merge them afterwards: system.time({ current_sum &lt;- 0 res3 &lt;- list() for (i in seq_along(x)) { current_sum &lt;- current_sum + x[i] res3[[i]] &lt;- current_sum } }) #&gt; user system elapsed #&gt; 0.02 0.00 0.02 all.equal(unlist(res3), res) #&gt; [1] TRUE With recent versions of R (&gt;= 3.4), you can efficiently grow a vector using system.time({ current_sum &lt;- 0 res4 &lt;- c() for (i in seq_along(x)) { current_sum &lt;- current_sum + x[i] res4[i] &lt;- current_sum } }) #&gt; user system elapsed #&gt; 0.01 0.00 0.01 all.equal(res4, res) #&gt; [1] TRUE Assigning to an element of a vector beyond the current length now over-allocates by a small fraction. The new vector is marked internally as growable, and the true length of the new vector is stored in the truelength field. This makes building up a vector result by assigning to the next element beyond the current length more efficient, though pre-allocating is still preferred. The implementation is subject to change and not intended to be used in packages at this time. (NEWS) An even better solution would be to avoid the loop by using a vectorized function: system.time(res5 &lt;- cumsum(x)) #&gt; user system elapsed #&gt; 0 0 0 all.equal(res5, res) #&gt; [1] TRUE x &lt;- rnorm(1e7) system.time(cumsum(x)) #&gt; user system elapsed #&gt; 0.05 0.00 0.04 As a second example, let us generate a matrix of uniform values (max changing for every column): n &lt;- 1e3 max &lt;- 1:1000 system.time({ mat &lt;- NULL for (m in max) { mat &lt;- cbind(mat, runif(n, max = m)) } }) #&gt; user system elapsed #&gt; 0.75 0.53 1.28 apply(mat, 2, max)[1:10] #&gt; [1] 0.9991986 1.9940086 2.9962345 3.9999273 4.9987388 5.9992458 6.9930093 7.9992494 #&gt; [9] 8.9772661 9.9800097 Instead, we should pre-allocate a matrix of the right size: system.time({ mat3 &lt;- matrix(0, n, length(max)) for (i in seq_along(max)) { mat3[, i] &lt;- runif(n, max = max[i]) } }) #&gt; user system elapsed #&gt; 0.03 0.00 0.04 apply(mat3, 2, max)[1:10] #&gt; [1] 0.9999853 1.9957334 2.9996715 3.9970219 4.9995861 5.9979513 6.9979957 7.9914500 #&gt; [9] 8.9947547 9.9966472 Or we could use a list instead. What is nice with using a list is that you don’t need to pre-allocate. Indeed, as opposed to atomic vectors, each element of a list is in different places in memory so that you don’t have to reallocate all the data when you add an element to a list. system.time({ l &lt;- list() for (i in seq_along(max)) { l[[i]] &lt;- runif(n, max = max[i]) } mat4 &lt;- do.call(&quot;cbind&quot;, l) }) #&gt; user system elapsed #&gt; 0.04 0.00 0.03 apply(mat4, 2, max)[1:10] #&gt; [1] 0.9996496 1.9979157 2.9991998 3.9944304 4.9934073 5.9929344 6.9899791 7.9934448 #&gt; [9] 8.9929622 9.9952065 Instead of pre-allocating yourself, you can use sapply (or lapply and calling do.call() after, as previously done): system.time( mat4 &lt;- sapply(max, function(m) runif(n, max = m)) ) #&gt; user system elapsed #&gt; 0.03 0.00 0.03 apply(mat4, 2, max)[1:10] #&gt; [1] 0.9995776 1.9994290 2.9924691 3.9962159 4.9814588 5.9921895 6.9949344 7.9836959 #&gt; [9] 8.9963762 9.9998817 Don’t listen to people telling you that sapply() is a vectorized operation that is so much faster than loops. That’s false, and for-loops can actually be much faster than sapply() when using just-in-time (JIT) compilation. You can learn more with this blog post. 5.2.2 Use the right function Often, in order to optimize your code, you can simply find the right function to do what you need to do. For example, rowMeans(x) is much faster than apply(x, 1, mean). Similarly, if you want more efficient functions that apply to rows and columns of matrices, you can check package {matrixStats}. Another example is when reading large text files; in such cases, prefer using data.table::fread() rather than read.table(). Generally, packages that uses C/Rcpp are efficient. 5.2.3 Do not try to optimize everything “Programmers waste enormous amounts of time thinking about, or worrying about, the speed of noncritical parts of their programs, and these attempts at efficiency actually have a strong negative impact when debugging and maintenance are considered.” — Donald Knuth. If you try to optimize each and every part of your code, you will end up losing a lot of time writing it, and it will probably make your code less readable. R is great at prototyping quickly because you can write code in a concise and easy way. Start by doing just that. If performance matters, then profile your code to see which part of your code is taking too much time and optimize only this part! Learn more on how to profile your code in RStudio in this article. 5.3 Vectorization I call vectorized a function that takes vectors as arguments and operate on each element of these vectors in another (compiled) language (such as C, C++ and Fortran). Again, sapply() is not a vectorized function (cf. above). Take this code: N &lt;- 10e3; x &lt;- runif(N); y &lt;- rnorm(N) res &lt;- double(length(x)) for (i in seq_along(x)) { res[i] &lt;- x[i] + y[i] } As an interpreted language, for each iteration res[i] &lt;- x[i] + y[i], R has to ask: what is the type of x[i] and y[i]? can I add these two types? what is the type of x[i] + y[i] then? can I store this result in res or do I need to convert it? These questions must be answered for each iteration, which takes time. Some of this is alleviated by JIT compilation. On the contrary, for vectorized functions, these questions must be answered only once, which saves a lot of time. Read more with Noam Ross’s blog post on vectorization. 5.3.1 Exercise Monte-Carlo integration (example from book Efficient R programming) Suppose we wish to estimate the integral \\(\\int_0^1 x^2 dx\\) using a Monte-Carlo method. Essentially, we throw darts (at random) and count the proportion of darts that fall below the curve (as in the following figure). Naively implementing this Monte-Carlo algorithm in R would typically lead to something like: monte_carlo &lt;- function(N) { hits &lt;- 0 for (i in seq_len(N)) { x &lt;- runif(1) y &lt;- runif(1) if (y &lt; x^2) { hits &lt;- hits + 1 } } hits / N } This takes a few seconds for N = 1e6: N &lt;- 2e5 system.time(res &lt;- monte_carlo(N)) #&gt; user system elapsed #&gt; 0.52 0.30 0.83 res #&gt; [1] 0.33386 Your task: find a vectorized solution for this problem: system.time(res2 &lt;- monte_carlo_vec(N)) #&gt; user system elapsed #&gt; 0.02 0.00 0.02 res2 #&gt; [1] 0.33295 5.4 Rcpp See this presentation. You have this data and this working code (a loop) that is slow mydf &lt;- readRDS(system.file(&quot;extdata/one-million.rds&quot;, package = &quot;advr38pkg&quot;)) QRA_3Dmatrix &lt;- array(0, dim = c(max(mydf$ID), max(mydf$Volume), 2)) for (i in seq_len(nrow(mydf))) { # Row corresponds to the ID class row &lt;- mydf$ID[i] # Column corresponds to the volume class column &lt;- mydf$Volume[i] # Number of events, initially zero, then +1 QRA_3Dmatrix[row, column, 1] &lt;- QRA_3Dmatrix[row, column, 1] + 1 # Sum energy QRA_3Dmatrix[row, column, 2] &lt;- QRA_3Dmatrix[row, column, 2] + 1 - 1.358 / (1 + exp( (1000 * mydf$Energy[i] - 129000) / 120300 )) } Rewrite this for-loop with Rcpp. You can also try to use {dplyr} for this problem. 5.5 Linear algebra In R, prefer using crossprod(X) and tcrossprod(X) instead of t(X) %*% X and X %*% t(X). Also using A %*% (B %*% y) and solve(A, y) will be faster than A %*% B %*% y and solve(A) %*% y. Don’t re-implement linear algebra operations (such as matrix products) yourself. There exist some highly optimized libraries for this. If you want to use linear algebra in Rcpp, try RcppArmadillo or RcppEigen. If you want to use some optimized multi-threaded linear library, you can try Microsoft R Open. 5.5.1 Exercises Compute the Euclidean distances between each of row of X and each row of Y: set.seed(1) X &lt;- matrix(rnorm(1000), ncol = 5) Y &lt;- matrix(rnorm(5000), ncol = 5) A naive implementation would be: system.time({ dist &lt;- matrix(NA_real_, nrow(X), nrow(Y)) for (i in seq_len(nrow(X))) { for (j in seq_len(nrow(Y))) { dist[i, j] &lt;- sqrt(sum((X[i, ] - Y[j, ])^2)) } } }) #&gt; user system elapsed #&gt; 0.25 0.00 0.25 Try first to remove one of the two loops using sweep() instead. Then, try to implement a fully vectorized solution based on this hint: \\(\\text{dist}(X_i, Y_j)^2 = (X_i - Y_j)^T (X_i - Y_j) = X_i^T X_i + Y_j^T Y_j - 2 X_i^T Y_j\\). A faster possible solution takes #&gt; user system elapsed #&gt; 0.00 0.01 0.02 5.6 Algorithms &amp; data structures Sometimes, getting the right data structure (e.g. using a matrix instead of a data frame or integers instead of characters) can save you some computation time. Is your algorithm doing some redundant computations making it e.g. quadratic instead of linear with respect to the dimension of your data? See exercises (section 5.7) for some insights. You can also find a detailed example in this blog post. 5.7 Exercises Generate \\(10^7\\) (start with \\(10^5\\)) steps of the process described by the formula:\\[X(0)=0\\]\\[X(t+1)=X(t)+Y(t)\\] where \\(Y(t)\\) are independent random variables with the distribution \\(N(0,1)\\). Then, calculate the percentage of \\(X(t)\\) that are negative. You do not need to store all values of \\(X\\). A naive implementation with a for-loop could be: set.seed(1) system.time({ N &lt;- 1e5 x &lt;- 0 count &lt;- 0 for (i in seq_len(N)) { y &lt;- rnorm(1) x &lt;- x + y if (x &lt; 0) count &lt;- count + 1 } p &lt;- count / N }) #&gt; user system elapsed #&gt; 0.22 0.04 0.25 p #&gt; [1] 0.88454 Try to vectorize this after having written the value of X(0), X(1), X(2), and X(3). What would be the benefit of writing an Rcpp function over a simple vectorized R function? set.seed(1) system.time(p2 &lt;- advr38pkg::random_walk_neg_prop(1e5)) #&gt; user system elapsed #&gt; 0.00 0.03 0.03 p2 #&gt; [1] 0.88454 set.seed(1) system.time(p3 &lt;- advr38pkg::random_walk_neg_prop(1e7)) #&gt; user system elapsed #&gt; 0.39 0.00 0.39 p3 #&gt; [1] 0.3400444 mat &lt;- as.matrix(mtcars) ind &lt;- seq_len(nrow(mat)) mat_big &lt;- mat[rep(ind, 1000), ] ## 1000 times bigger dataset last_row &lt;- mat_big[nrow(mat_big), ] Speed up these loops (vectorize): system.time({ for (j in 1:ncol(mat_big)) { for (i in 1:nrow(mat_big)) { mat_big[i, j] &lt;- 10 * mat_big[i, j] * last_row[j] } } }) #&gt; user system elapsed #&gt; 0.44 0.00 0.44 Why colSums() on a whole matrix is faster than on only half of it? m0 &lt;- matrix(rnorm(1e6), 1e3, 1e3) microbenchmark::microbenchmark( colSums(m0[, 1:500]), colSums(m0) ) #&gt; Unit: microseconds #&gt; expr min lq mean median uq max neval #&gt; colSums(m0[, 1:500]) 1773.1 1905.7 2215.284 1975.8 2124.55 7196.6 100 #&gt; colSums(m0) 806.0 845.3 902.621 862.5 933.35 1473.8 100 Try to speed up this code by vectorizing it first, and/or by precomputing. Then, recode it in Rcpp and benchmark all the solutions you came up with. M &lt;- 50 step1 &lt;- runif(M) A &lt;- rnorm(M) N &lt;- 1e4 tau &lt;- matrix(0, N + 1, M) tau[1, ] &lt;- A for (j in 1:M) { for (i in 2:nrow(tau)) { tau[i, j] &lt;- tau[i - 1, j] + step1[j] * 1.0025^(i - 2) } } Make a fast function that counts the number of elements between a sequence of breaks. Can you do it in base R? Try also implementing it in Rcpp. How can you implement a solution whose computation time doesn’t depend on the number of breaks? [Which are the special cases that you should consider?] x &lt;- sample(10, size = 1e4, replace = TRUE) breaks &lt;- c(1, 3, 8.5, 9.5, 10) table(cut(x, breaks), exclude = NULL) # does not include first break (1) #&gt; #&gt; (1,3] (3,8.5] (8.5,9.5] (9.5,10] &lt;NA&gt; #&gt; 2006 4970 1027 944 1053 hist(x, breaks, plot = FALSE)$counts # includes first break #&gt; [1] 3059 4970 1027 944 advr38pkg::count_by_breaks(x, breaks) #&gt; [1] 2006 4970 1027 944 advr38pkg::count_by_breaks_fast(x, breaks) #&gt; [1] 2006 4970 1027 944 microbenchmark::microbenchmark( table(cut(x, breaks)), hist(x, breaks, plot = FALSE)$counts, advr38pkg::count_by_breaks(x, breaks, use_outer = TRUE), advr38pkg::count_by_breaks(x, breaks, use_outer = FALSE), advr38pkg::count_by_breaks_fast(x, breaks) ) #&gt; Unit: microseconds #&gt; expr min lq mean median #&gt; table(cut(x, breaks)) 844.6 953.05 1149.641 1008.80 #&gt; hist(x, breaks, plot = FALSE)$counts 377.3 425.65 476.340 453.45 #&gt; advr38pkg::count_by_breaks(x, breaks, use_outer = TRUE) 394.0 503.80 562.358 533.95 #&gt; advr38pkg::count_by_breaks(x, breaks, use_outer = FALSE) 219.0 243.10 280.665 262.00 #&gt; advr38pkg::count_by_breaks_fast(x, breaks) 184.6 211.00 330.215 223.05 #&gt; uq max neval #&gt; 1092.2 11430.2 100 #&gt; 492.0 782.9 100 #&gt; 577.1 1090.7 100 #&gt; 297.1 454.6 100 #&gt; 241.2 9789.6 100 x2 &lt;- sample(100, size = 1e5, replace = TRUE) breaks2 &lt;- breaks * 10 breaks3 &lt;- seq(0, 100, length.out = 100) microbenchmark::microbenchmark( advr38pkg::count_by_breaks(x2, breaks2), advr38pkg::count_by_breaks_fast(x2, breaks2), advr38pkg::count_by_breaks(x2, breaks3), advr38pkg::count_by_breaks_fast(x2, breaks3) ) #&gt; Unit: milliseconds #&gt; expr min lq mean median #&gt; advr38pkg::count_by_breaks(x2, breaks2) 1.7526 2.02530 2.329821 2.21715 #&gt; advr38pkg::count_by_breaks_fast(x2, breaks2) 1.4366 1.64645 2.151907 1.88430 #&gt; advr38pkg::count_by_breaks(x2, breaks3) 34.4520 40.48460 48.245890 48.85765 #&gt; advr38pkg::count_by_breaks_fast(x2, breaks3) 1.4640 1.62270 1.966308 1.75355 #&gt; uq max neval #&gt; 2.50025 5.4691 100 #&gt; 2.07780 11.2897 100 #&gt; 52.26970 73.7237 100 #&gt; 2.09165 11.9069 100 An R user wants to implement some sampling on a sparse matrix and provides this working code: N &lt;- 2000 system.time({ m &lt;- Matrix::Matrix(0, nrow = N, ncol = N) for (j in 1:N) { cols &lt;- sample((1:N)[-j], 2) # pick 2 columns that are not j m[j, cols] &lt;- 1 } }) #&gt; user system elapsed #&gt; 2.06 0.03 2.09 This code is slow; can you find two major reasons why? How can you more efficiently assign 1s? A faster solution would take: #&gt; user system elapsed #&gt; 0.06 0.02 0.08 Can you use sampling with replacement (to avoid unnecessarily allocating memory) in this example? A faster solution would take: #&gt; user system elapsed #&gt; 0.03 0.00 0.03 It would be even faster using Rcpp (cf. this SO answer). Make a fast function that returns all prime numbers up to a number N. N &lt;- 1e6 system.time( primes &lt;- advr38pkg::AllPrimesUpTo(N) ) #&gt; user system elapsed #&gt; 0.05 0.00 0.05 plot(primes, pch = 20, cex = 0.5) 5.8 Parallel computing I basically always use foreach and recommend to do so. See my guide to parallelism in R with foreach. Just remember to optimize your code before trying to parallelize it. Try to parallelize some of your best solutions for the previous exercises. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
