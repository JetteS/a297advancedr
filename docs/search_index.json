[["index.html", "Advanced R Course Originally, materials for the doctoral school of Grenoble, France About License Author", " Advanced R Course Originally, materials for the doctoral school of Grenoble, France Florian Privé 2023-08-18 About License This material is licensed under the Creative Commons Attribution-ShareAlike 3.0 License. Author Florian Privé is a researcher in predictive human genetics, fond of Data Science and an R(cpp) enthusiast. He is also the founder and former organizer of the Grenoble R user group. You can find him on Twitter and GitHub as @privefl and on Stack Overflow as F. Privé. "],["introduction.html", "Chapter 1 Introduction 1.1 Prerequisites 1.2 Content 1.3 Useful resources", " Chapter 1 Introduction 1.1 Prerequisites Have at least a basic knowledge of R, Install recent versions of R (&gt;= 3.4) and RStudio (&gt;= 1.2), Install associated package advr38pkg with remotes::install_github(\"privefl/advr38pkg\"); this will install other dependencies that are needed in this book. Install Git and create a GitHub account 1.2 Content It is impossible to become expert in R in one training course only. Yet, this course aims at giving a wide understanding of many aspects of R. Some external resources are referred to in this book for you to be able to deepen what you have learned in this course. This course was originally composed of 9 sessions (3 hours each): R programming and good practices (1.5 sessions) Data analysis with the tidyverse (3.5 sessions) R code performance (2 sessions) R packages (1 session) Bonus: Shiny (1 session) The program is now composed of 10 sessions over a full week: R programming and good practices (1.5 sessions) Data analysis with the tidyverse (3.5 sessions) R code performance (1 session) R packages (1 session) Project preparation + presentation (3 sessions) 1.3 Useful resources Course on R debugging and robust programming by Laurent Gatto &amp; Robert Stojnic, Data Challenge Lab by Hadley Wickham, Advanced R by Hadley Wickham, and some solutions, R for Data Science by Garrett Grolemund &amp; Hadley Wickham, and some solutions, R packages by Hadley Wickham, Efficient R programming by Colin Gillespie &amp; Robin Lovelace, R Programming for Data Science by Roger D. Peng, Mastering Software Development in R by Roger D. Peng, Sean Kross and Brooke Anderson, other resources linked from these materials. "],["good-practices.html", "Chapter 2 Good practices 2.1 Coding style 2.2 RStudio 2.3 Version control (Git) 2.4 Getting help", " Chapter 2 Good practices 2.1 Coding style Good coding style is like correct punctuation: you can manage without it, butitsuremakesthingseasiertoread. – Hadley Wickham Please make your code readable by following e.g. this coding style. Hereinafter I provide some examples from this guide. You can use package styler (that provides RStudio addins) to correct your style: You can also use Ctrl+Shift+A in RStudio; we will talk about RStudio shortcuts in section 2.2. 2.1.1 Naming Be smart with your naming. I can’t tell the number of times I’ve seen df &lt;- as.matrix(mtcars) on Stack Overflow. 2.1.2 Spacing Put a space before and after = when naming arguments in function calls. Most infix operators (==, +, -, &lt;-, etc.) are also surrounded by spaces, except those with relatively high precedence: ^, :, ::, and :::. Always put a space after a comma, and never before (just like in regular English). # Good average &lt;- mean((feet / 12) + inches, na.rm = TRUE) x &lt;- 1:10 base::sum # Bad average&lt;-mean(feet/12+inches,na.rm=TRUE) x &lt;- 1 : 10 base :: sum 2.1.3 Indenting Curly braces, {}, define the most important hierarchy of R code. To make this hierarchy easy to see, always indent the code inside {} by two spaces. This should be automatic in RStudio. # Good if (y &lt; 0 &amp;&amp; debug) { message(&quot;y is negative&quot;) } if (y == 0) { if (x &gt; 0) { log(x) } else { message(&quot;x is negative or zero&quot;) } } else { y ^ x } # Bad if (y &lt; 0 &amp;&amp; debug) message(&quot;Y is negative&quot;) if (y == 0) { if (x &gt; 0) { log(x) } else { message(&quot;x is negative or zero&quot;) } } else { y ^ x } 2.1.4 Long lines Strive to limit your code to 80 characters per line. This fits comfortably on your screen with a reasonably sized font. If you find yourself running out of room, this is a good indication that you should encapsulate some of the work in a separate function. In RStudio -&gt; Tools -&gt; Global Options, set 2.1.5 Other Use &lt;-, not =, for assignment. Keep = for parameters. # Good x &lt;- 5 system.time( x &lt;- rnorm(1e6) ) # Bad x = 5 system.time( x = rnorm(1e6) ) Don’t put ; at the end of a line, and avoid multiple commands on the same line. Only use return() for early returns. Otherwise rely on R to return the result of the last evaluated expression. # Good add_two &lt;- function(x, y) { x + y } # Bad add_two &lt;- function(x, y) { return(x + y) } Use \", not ', for quoting text. The only exception is when the text already contains double quotes and no single quotes. # Good &quot;Text&quot; &#39;Text with &quot;quotes&quot;&#39; &#39;&lt;a href=&quot;http://style.tidyverse.org&quot;&gt;A link&lt;/a&gt;&#39; # Bad &#39;Text&#39; &#39;Text with &quot;double&quot; and \\&#39;single\\&#39; quotes&#39; 2.2 RStudio Download a recent enough version of RStudio (&gt;= 1.2) and use it! Learn more about the new features of RStudio at https://rstudio.com/products/rstudio/release-notes/. RStudio features: everything you can expect from a good IDE keyboard shortcuts I use Ctrl + Space (auto-completion, better than Tab) Ctrl + Up (command history &amp; search) Ctrl + Click (function source code) Ctrl + Enter (execute line of code) Ctrl + Shift + A (reformat code) Ctrl + Shift + C (comment/uncomment selected lines) Ctrl + Shift + K (knit) Ctrl + Shift + B (build package, website or book) Ctrl + Shift + M (pipe) Alt + Shift + K to see all shortcuts… Panels (everything is integrated, including Git and a terminal) Interactive data importation from files and connections (see this webinar) Use code diagnostics: RStudio Projects: Meaningful structure in one folder The working directory automatically switches to the project’s folder The File tab displays the associated files and folders in the project History of R commands and open files Any settings associated with the project, such as Git settings, are loaded. Note that you can have a .Rprofile file in the project’s root directory to enable project-specific settings to be loaded each time people open the project. Read more at https://www.tidyverse.org/articles/2017/12/workflow-vs-script/ and also see chapter Efficient set-up of book Efficient R programming. 2.3 Version control (Git) 2.3.1 Why use Git? You don’t use Git? Figure 2.1: You don’t use Version Control? Have you ever: Made a change to code, realized it was a mistake and wanted to revert back? Lost code or had a backup that was too old? Wanted to submit a change to someone else’s code? Wanted to share your code, or let other people work on your code? In these cases, and probably many others, a version control system should make your life easier (see https://stackoverflow.com/a/1408464/6103040). Version control for the researcher: don’t do that, use Git Version control for the data analyst: reproducible workflow Also, see https://stackoverflow.com/q/2712421/6103040. Use version control to work from anywhere Working with GitHub can be a line on your CV (read more): A lot of students have said to me later, even first-year undergraduates, that using GitHub has helped them a lot when they went for an internship or a research position interview. They are able to say, “Oh, I already have worked with GitHub. I am familiar with it. I know how it works.” So I think they are at least able to put that on their CV and go into a situation where there’s a research or data analysis team and say, “Yeah, sure. I am actually familiar with the same tools that you use.” – Mine Cetinkaya-Rundel, Duke University, RStudio Be able to get websites for your packages with pkgdown, for your book (like this one!) with bookdown, for your personal webpage with R Markdown Websites or blogdown. 2.3.2 About Git Main Git platforms (share your code, collaborate): GitHub, documentation (only free for public repositories, now owned by Microsoft) GitLab (open source &amp; free) Bitbucket (free when you have less than 5 collaborators) any server.. 4 main commands: add: add files to be part of the next commit commit: snapshot of your code at a specified point in time (you can and you should use this even when having no internet connection) push: merge your local modifications with the main project pull: update your local project with the latest version of the main project Simple (solo) use of git to prevent merge conflicts: after opening a project, always pull before closing a project, always commit/push Use git even when you do not have any internet connection! (e.g. on a secure server) Just use commits for version control locally. How to link between an RStudio project and a GitHub repository? For Mac users, you might need to use the terminal for git clone, then create the RStudio project from the existing directory. If you have some permission denied for the public key, you might also need to run ssh-agent -s &amp;&amp; ssh-add &lt;path_to_public_key&gt; (cf. this SO answer). Help with Git: Happy Git and GitHub for the useR Git cheat sheet When things go wrong To fix a mistake Create a new branch with git and manage branches 2.4 Getting help 2.4.1 Help yourself, learn how to debug A basic solution is to print everything, but it’s usually not working well on complex problems. A convenient solution to see all the variables’ states in your code is to place some browser() from where you want to check the variables’ states. To debug functions, debugonce() is also very useful. my_log &lt;- function(x) log(x - 1) my_fun &lt;- function(a, b) { # browser() la &lt;- my_log(a) lb &lt;- my_log(b) la + lb } my_fun(1, 0) #&gt; Warning in log(x - 1): NaNs produced #&gt; [1] NaN Try to uncomment browser() or use debugonce(my_fun): debugonce(my_fun) my_fun(1, 0) Learn more with this book chapter, this other book chapter, this webinar and this RStudio article. 2.4.2 External help Can’t remember useful functions? Use cheat sheets. You can search for specific R stuff on https://rseek.org/. You should also read documentations carefully. If you’re using a package, search for vignettes and a GitHub repository. You can also use Stack Overflow. The most common use of Stack Overflow is when you have an error or a question, you google it, and most of the times the first links are Q/A on Stack Overflow. You can ask questions on Stack Overflow (using the tag r). You need to make a great R reproducible example if you want your question to be answered. Sometimes, while making this minimal reproducible example, you end up understanding and solving the issue on your own. If you are confident enough with your R skills, you can take the next step and answer questions on Stack Overflow. It’s a good way to increase your skills, or just to procrastinate while writing a scientific manuscript. You can also join communities, e.g. join the French-speaking R community or join the R-Ladies community on Slack. These are generally much friendlier and welcoming spaces compared to Stack Overflow. "],["r-programming.html", "Chapter 3 R programming 3.1 Common mistakes 3.2 R base objects 3.3 Base objects and accessors 3.4 Useful R base functions 3.5 Environments and scoping 3.6 Attributes and classes", " Chapter 3 R programming This chapter is about base R stuff that I find important and that is often overlooked or unknown to most R users. Learn more with the Advanced R book. 3.1 Common mistakes If you are using R and you think you’re in hell, this is a map for you. – Patrick Burns 3.1.1 Equality (0.1 + 0.2) == 0.3 #&gt; [1] FALSE print(c(0.1, 0.2, 0.3), digits = 20) #&gt; [1] 0.10000000000000000555 0.20000000000000001110 0.29999999999999998890 all.equal(0.1 + 0.2, 0.3) ## equality with some tolerance #&gt; [1] TRUE all.equal(0.1 + 0.2, 0.4) #&gt; [1] &quot;Mean relative difference: 0.3333333&quot; isTRUE(all.equal(0.1 + 0.2, 0.4)) ## if you want a boolean, use isTRUE() #&gt; [1] FALSE 3.1.2 Arguments min(-1, 5, 118) #&gt; [1] -1 max(-1, 5, 118) #&gt; [1] 118 mean(-1, 5, 118) #&gt; [1] -1 median(-1, 5, 118) #&gt; [1] -1 How to explain the issue with mean and median? Let us look at the parameters of these functions: args(max) #&gt; function (..., na.rm = FALSE) #&gt; NULL args(mean) #&gt; function (x, ...) #&gt; NULL args(median) #&gt; function (x, na.rm = FALSE, ...) #&gt; NULL One solution is to always use a vector: min(c(-1, 5, 118)) #&gt; [1] -1 max(c(-1, 5, 118)) #&gt; [1] 118 mean(c(-1, 5, 118)) #&gt; [1] 40.66667 median(c(-1, 5, 118)) #&gt; [1] 5 3.1.3 Others sample(1:10) #&gt; [1] 2 4 3 1 6 9 10 8 5 7 sample(10) #&gt; [1] 4 8 3 5 10 9 1 7 6 2 sample(10.1) #&gt; [1] 10 1 2 9 5 4 6 8 3 7 n &lt;- 10 1:n-1 ## is (1:n) - 1, so 0:(n - 1) #&gt; [1] 0 1 2 3 4 5 6 7 8 9 1:(n-1) #&gt; [1] 1 2 3 4 5 6 7 8 9 seq_len(n - 1) #&gt; [1] 1 2 3 4 5 6 7 8 9 1:0 #&gt; [1] 1 0 seq_len(0) ## prefer using seq_len(n) rather than 1:n (e.g. in for-loops) #&gt; integer(0) seq_along(5:7) ## a shortcut for seq_len(length(.)) #&gt; [1] 1 2 3 3.2 R base objects 3.2.1 Types There are several “atomic” types of data: logical, integer, double and character (in this order, see below). There are also raw and complex, but they are rarely used. You cannot mix types in an atomic vector, but you can in a list. Coercion will automatically occur when you mix types in a vector: (a &lt;- FALSE) #&gt; [1] FALSE typeof(a) #&gt; [1] &quot;logical&quot; (b &lt;- 1:10) #&gt; [1] 1 2 3 4 5 6 7 8 9 10 typeof(b) #&gt; [1] &quot;integer&quot; c(a, b) ## FALSE is coerced to an integer -&gt; 0 #&gt; [1] 0 1 2 3 4 5 6 7 8 9 10 (c &lt;- 10.5) #&gt; [1] 10.5 typeof(c) #&gt; [1] &quot;double&quot; (d &lt;- c(b, c)) ## coerced to numeric #&gt; [1] 1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0 10.0 10.5 c(d, &quot;a&quot;) ## coerced to character #&gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; &quot;10.5&quot; &quot;a&quot; c(list(1), &quot;a&quot;) #&gt; [[1]] #&gt; [1] 1 #&gt; #&gt; [[2]] #&gt; [1] &quot;a&quot; 50 &lt; &quot;7&quot; ## does &quot;50&quot; &lt; &quot;7&quot; #&gt; [1] TRUE 3.2.2 Exercise Use the automatic type coercion to convert this boolean matrix to a numeric one (with 0s and 1s). [What do you need to change in your code to get an integer matrix instead of a numeric one?] (mat &lt;- matrix(sample(c(TRUE, FALSE), 12, replace = TRUE), nrow = 3)) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] FALSE FALSE FALSE FALSE #&gt; [2,] FALSE FALSE TRUE FALSE #&gt; [3,] TRUE TRUE FALSE FALSE 3.3 Base objects and accessors 3.3.1 Objects “atomic” vector: vector of one base type (see above). scalar: this doesn’t exist, this is a vector of length 1. matrices / arrays: a vector with some dimensions (attribute). (vec &lt;- 1:12) #&gt; [1] 1 2 3 4 5 6 7 8 9 10 11 12 dim(vec) &lt;- c(3, 4) vec #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 class(vec) #&gt; [1] &quot;matrix&quot; &quot;array&quot; dim(vec) &lt;- c(3, 2, 2) vec #&gt; , , 1 #&gt; #&gt; [,1] [,2] #&gt; [1,] 1 4 #&gt; [2,] 2 5 #&gt; [3,] 3 6 #&gt; #&gt; , , 2 #&gt; #&gt; [,1] [,2] #&gt; [1,] 7 10 #&gt; [2,] 8 11 #&gt; [3,] 9 12 class(vec) #&gt; [1] &quot;array&quot; list: vector of elements with possibly different types in it. data.frame: a list whose elements have the same lengths, and formatted somewhat as a matrix. head(iris) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 1 5.1 3.5 1.4 0.2 setosa #&gt; 2 4.9 3.0 1.4 0.2 setosa #&gt; 3 4.7 3.2 1.3 0.2 setosa #&gt; 4 4.6 3.1 1.5 0.2 setosa #&gt; 5 5.0 3.6 1.4 0.2 setosa #&gt; 6 5.4 3.9 1.7 0.4 setosa dim(iris) #&gt; [1] 150 5 length(iris) ## a data.frame is also a list #&gt; [1] 5 3.3.2 Accessors The [ accessor is used to access a subset of the data with the same class. (x &lt;- runif(5)) #&gt; [1] 0.4404068 0.6296426 0.5179156 0.9817906 0.3562055 x[2:3] #&gt; [1] 0.6296426 0.5179156 x[2:8] ## /!\\ no warning #&gt; [1] 0.6296426 0.5179156 0.9817906 0.3562055 NA NA NA (y &lt;- matrix(runif(12), nrow = 3)) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 0.9918396 0.69267319 0.5447564 0.86770501 #&gt; [2,] 0.3271237 0.45891194 0.7785806 0.96100707 #&gt; [3,] 0.1513844 0.06368535 0.7310707 0.02874036 y[4:9] ## a matrix is also a vector #&gt; [1] 0.69267319 0.45891194 0.06368535 0.54475643 0.77858058 0.73107067 (l &lt;- list(a = 1, b = &quot;I love R&quot;, c = matrix(runif(6), nrow = 2))) #&gt; $a #&gt; [1] 1 #&gt; #&gt; $b #&gt; [1] &quot;I love R&quot; #&gt; #&gt; $c #&gt; [,1] [,2] [,3] #&gt; [1,] 0.8439863 0.7849749 0.43777572 #&gt; [2,] 0.2345017 0.8923982 0.03633002 l[2:3] #&gt; $b #&gt; [1] &quot;I love R&quot; #&gt; #&gt; $c #&gt; [,1] [,2] [,3] #&gt; [1,] 0.8439863 0.7849749 0.43777572 #&gt; [2,] 0.2345017 0.8923982 0.03633002 head(iris) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 1 5.1 3.5 1.4 0.2 setosa #&gt; 2 4.9 3.0 1.4 0.2 setosa #&gt; 3 4.7 3.2 1.3 0.2 setosa #&gt; 4 4.6 3.1 1.5 0.2 setosa #&gt; 5 5.0 3.6 1.4 0.2 setosa #&gt; 6 5.4 3.9 1.7 0.4 setosa head(iris[3:4]) #&gt; Petal.Length Petal.Width #&gt; 1 1.4 0.2 #&gt; 2 1.4 0.2 #&gt; 3 1.3 0.2 #&gt; 4 1.5 0.2 #&gt; 5 1.4 0.2 #&gt; 6 1.7 0.4 class(iris[5]) #&gt; [1] &quot;data.frame&quot; You can also use a logical and character vectors to index these objects. (x &lt;- runif(4)) #&gt; [1] 0.01750034 0.60394820 0.92248922 0.49382304 x[c(FALSE, TRUE, FALSE, TRUE)] #&gt; [1] 0.6039482 0.4938230 x[c(FALSE, TRUE)] ## logical vectors are recycled #&gt; [1] 0.6039482 0.4938230 head(iris[c(&quot;Petal.Length&quot;, &quot;Species&quot;)]) #&gt; Petal.Length Species #&gt; 1 1.4 setosa #&gt; 2 1.4 setosa #&gt; 3 1.3 setosa #&gt; 4 1.5 setosa #&gt; 5 1.4 setosa #&gt; 6 1.7 setosa The [[ accessor is used to access a single element. (x &lt;- 1:10) #&gt; [1] 1 2 3 4 5 6 7 8 9 10 x[[3]] #&gt; [1] 3 l[[2]] #&gt; [1] &quot;I love R&quot; iris[[&quot;Species&quot;]] #&gt; [1] setosa setosa setosa setosa setosa setosa setosa setosa setosa setosa setosa setosa #&gt; [13] setosa setosa setosa setosa setosa setosa setosa setosa setosa setosa setosa setosa #&gt; [25] setosa setosa setosa setosa setosa setosa setosa setosa setosa setosa setosa setosa #&gt; [37] setosa setosa setosa setosa setosa setosa setosa setosa setosa setosa setosa setosa #&gt; [49] setosa setosa #&gt; [ reached getOption(&quot;max.print&quot;) -- omitted 100 entries ] #&gt; Levels: setosa versicolor virginica Figure 3.1: Indexing lists in R. [Source: https://goo.gl/8UkcHq] Beware partial matching x &lt;- list(aardvark = 1:5) x$a #&gt; [1] 1 2 3 4 5 x[[&quot;a&quot;]] #&gt; NULL x[[&quot;a&quot;, exact = FALSE]] #&gt; [1] 1 2 3 4 5 Special use of the [ accessor for array-like data. (mat &lt;- matrix(1:12, 3)) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 mat[1, ] #&gt; [1] 1 4 7 10 mat[, 1:2] #&gt; [,1] [,2] #&gt; [1,] 1 4 #&gt; [2,] 2 5 #&gt; [3,] 3 6 mat[1, 1:2] #&gt; [1] 1 4 mat[1, 1:2, drop = FALSE] #&gt; [,1] [,2] #&gt; [1,] 1 4 (two_col_ind &lt;- cbind(c(1, 3, 2), c(1, 4, 2))) #&gt; [,1] [,2] #&gt; [1,] 1 1 #&gt; [2,] 3 4 #&gt; [3,] 2 2 mat[two_col_ind] #&gt; [1] 1 12 5 mat[] #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 mat[] &lt;- 2 mat #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 2 2 2 2 #&gt; [2,] 2 2 2 2 #&gt; [3,] 2 2 2 2 If you use arrays with more than two dimensions, simply add an additional comma for every new dimension. 3.3.3 Exercises Use the dimension attribute to make a function that computes the sums every n elements of a vector. In which order are matrix elements stored? [Which are the special cases that you should consider?] advr38pkg::sum_every(1:10, 2) #&gt; [1] 3 7 11 15 19 Compute the means of every numeric columns of the iris dataset. Expected result: #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width #&gt; 5.843333 3.057333 3.758000 1.199333 Convert the following matrix to a vector by replacing (0, 0) -&gt; 0; (0, 1) -&gt; 1; (1, 1) -&gt; 2; (1, 0) -&gt; NA. mat &lt;- matrix(0, 10, 2); mat[c(5, 8, 9, 12, 15, 16, 17, 19)] &lt;- 1; mat #&gt; [,1] [,2] #&gt; [1,] 0 0 #&gt; [2,] 0 1 #&gt; [3,] 0 0 #&gt; [4,] 0 0 #&gt; [5,] 1 1 #&gt; [6,] 0 1 #&gt; [7,] 0 1 #&gt; [8,] 1 0 #&gt; [9,] 1 1 #&gt; [10,] 0 0 by using this matrix: (decode &lt;- matrix(c(0, NA, 1, 2), 2)) #&gt; [,1] [,2] #&gt; [1,] 0 1 #&gt; [2,] NA 2 Start by doing it for one row, then by using apply(), finally replace it by a special accessor; what is the benefit? Expected result: #&gt; [1] 0 1 0 0 2 1 1 NA 2 0 3.4 Useful R base functions In this section, I present some useful R base functions (also see this comprehensive list in French and this one in English): 3.4.1 General # To get some help ?topic # Run code from the example section example(sum) # Structure overview str(iris) #&gt; &#39;data.frame&#39;: 150 obs. of 5 variables: #&gt; $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... #&gt; $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... #&gt; $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... #&gt; $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... #&gt; $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... # List objects in the environment ls() #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;decode&quot; &quot;l&quot; #&gt; [7] &quot;mat&quot; &quot;n&quot; &quot;osef&quot; &quot;two_col_ind&quot; &quot;vec&quot; &quot;x&quot; #&gt; [13] &quot;y&quot; # Remove objects from the environment rm(list = ls()) ## remove all objects in the global environment # For a particular method, list available implementations for different classes methods(summary) #&gt; [1] summary.aov summary.aovlist* #&gt; [3] summary.aspell* summary.check_packages_in_dir* #&gt; [5] summary.connection summary.data.frame #&gt; [7] summary.Date summary.default #&gt; [9] summary.ecdf* summary.factor #&gt; [11] summary.glm summary.infl* #&gt; [13] summary.lm summary.loess* #&gt; [15] summary.manova summary.matrix #&gt; [17] summary.mlm* summary.nls* #&gt; [19] summary.packageStatus* summary.POSIXct #&gt; [21] summary.POSIXlt summary.ppr* #&gt; [23] summary.prcomp* summary.princomp* #&gt; [25] summary.proc_time summary.rlang:::list_of_conditions* #&gt; [27] summary.rlang_error* summary.rlang_message* #&gt; [29] summary.rlang_trace* summary.rlang_warning* #&gt; [31] summary.srcfile summary.srcref #&gt; [33] summary.stepfun summary.stl* #&gt; [35] summary.table summary.tukeysmooth* #&gt; [37] summary.warnings #&gt; see &#39;?methods&#39; for accessing help and source code # List methods available for a particular class methods(class = &quot;lm&quot;) #&gt; [1] add1 alias anova case.names coerce #&gt; [6] confint cooks.distance deviance dfbeta dfbetas #&gt; [11] drop1 dummy.coef effects extractAIC family #&gt; [16] formula hatvalues influence initialize kappa #&gt; [21] labels logLik model.frame model.matrix nobs #&gt; [26] plot predict print proj qr #&gt; [31] residuals rstandard rstudent show simulate #&gt; [36] slotsFromS3 summary variable.names vcov #&gt; see &#39;?methods&#39; for accessing help and source code # Call a function with arguments as a list (list_of_int &lt;- as.list(1:5)) #&gt; [[1]] #&gt; [1] 1 #&gt; #&gt; [[2]] #&gt; [1] 2 #&gt; #&gt; [[3]] #&gt; [1] 3 #&gt; #&gt; [[4]] #&gt; [1] 4 #&gt; #&gt; [[5]] #&gt; [1] 5 do.call(&#39;c&#39;, list_of_int) #&gt; [1] 1 2 3 4 5 3.4.2 Sequence and vector operations 1:10 ## of type integer #&gt; [1] 1 2 3 4 5 6 7 8 9 10 seq(1, 10, by = 2) ## of type double #&gt; [1] 1 3 5 7 9 seq(1, 100, length.out = 10) #&gt; [1] 1 12 23 34 45 56 67 78 89 100 seq_len(5) #&gt; [1] 1 2 3 4 5 seq_along(21:24) #&gt; [1] 1 2 3 4 rep(1:4, 2) #&gt; [1] 1 2 3 4 1 2 3 4 rep(1:4, each = 2) #&gt; [1] 1 1 2 2 3 3 4 4 rep(1:4, 4:1) #&gt; [1] 1 1 1 1 2 2 2 3 3 4 rep_len(1:3, 8) #&gt; [1] 1 2 3 1 2 3 1 2 replicate(5, rnorm(10)) ## How to use a multiline expression? #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] 0.4100572 1.2702117 -0.78165033 -0.98508648 -0.2723045 #&gt; [2,] 0.4179705 0.8817942 -0.48899793 -0.84841942 -2.0698664 #&gt; [3,] -2.0559871 0.7614714 1.45015506 -0.16750177 0.1646303 #&gt; [4,] 1.0624853 -1.3870442 -0.45892800 0.96276524 0.1858542 #&gt; [5,] -0.6305950 -0.2959886 0.51963625 0.55111871 0.9137594 #&gt; [6,] -0.5512800 0.7519389 1.35965972 -0.33476109 1.3041367 #&gt; [7,] -0.4337894 1.1584924 -1.07156293 1.47577008 1.4275239 #&gt; [8,] 0.2823651 -0.3446400 -0.75939787 0.93896851 -0.7544881 #&gt; [9,] 0.4655851 1.5121254 1.52862740 -0.09328371 -1.6310602 #&gt; [10,] 0.2626154 1.5300460 -0.03329988 1.00144089 0.4939048 sort(c(1, 6, 8, 2, 2)) #&gt; [1] 1 2 2 6 8 order(c(1, 6, 8, 2, 2), c(0, 0, 0, 2, 1)) #&gt; [1] 1 5 4 2 3 rank(c(1, 6, 8, 2, 2)) #&gt; [1] 1.0 4.0 5.0 2.5 2.5 rank(c(1, 6, 8, 2, 2), ties.method = &quot;first&quot;) #&gt; [1] 1 4 5 2 3 sort(c(&quot;a1&quot;, &quot;a2&quot;, &quot;a10&quot;)) #&gt; [1] &quot;a1&quot; &quot;a10&quot; &quot;a2&quot; gtools::mixedsort(c(&quot;a1&quot;, &quot;a2&quot;, &quot;a10&quot;)) ## not in base, but useful #&gt; [1] &quot;a1&quot; &quot;a2&quot; &quot;a10&quot; which.max(c(1, 5, 3, 6, 2, 0)) #&gt; [1] 4 which.min(c(1, 5, 3, 6, 2, 0)) #&gt; [1] 6 unique(c(1, NA, 2, 3, 2, NA, 3)) #&gt; [1] 1 NA 2 3 table(rep(1:4, 4:1)) #&gt; #&gt; 1 2 3 4 #&gt; 4 3 2 1 table(A = c(1, 1, 1, 2, 2), B = c(1, 2, 1, 2, 1)) #&gt; B #&gt; A 1 2 #&gt; 1 2 1 #&gt; 2 1 1 sample(10) #&gt; [1] 3 5 9 10 6 7 2 4 8 1 sample(3:10, 5) #&gt; [1] 3 8 5 6 9 sample(3:10, 50, replace = TRUE) #&gt; [1] 7 9 3 8 7 4 4 9 5 3 7 7 3 10 10 9 9 4 5 9 4 10 5 9 8 9 6 3 #&gt; [29] 6 3 4 3 3 4 5 5 4 10 7 7 8 8 7 8 3 4 7 3 8 6 round(x &lt;- runif(10, max = 100)) #&gt; [1] 16 51 12 36 16 29 10 10 73 38 round(x, digits = 2) #&gt; [1] 15.64 51.33 12.03 36.50 15.79 28.57 9.86 10.38 72.71 38.38 round(x, -1) #&gt; [1] 20 50 10 40 20 30 10 10 70 40 pmin(1:4, 4:1) #&gt; [1] 1 2 2 1 pmax(1:4, 4:1) #&gt; [1] 4 3 3 4 outer(1:4, 1:3, &#39;+&#39;) #&gt; [,1] [,2] [,3] #&gt; [1,] 2 3 4 #&gt; [2,] 3 4 5 #&gt; [3,] 4 5 6 #&gt; [4,] 5 6 7 expand.grid(param1 = c(5, 50), param2 = c(1, 3, 10)) #&gt; param1 param2 #&gt; 1 5 1 #&gt; 2 50 1 #&gt; 3 5 3 #&gt; 4 50 3 #&gt; 5 5 10 #&gt; 6 50 10 Also see this nice Q/A on grouping functions and the *apply family and this book chapter about looping. 3.4.3 Character operations paste(&quot;I&quot;, &quot;am&quot;, &quot;me&quot;) #&gt; [1] &quot;I am me&quot; paste0(&quot;test&quot;, 0) #&gt; [1] &quot;test0&quot; paste0(&quot;PC&quot;, 1:10) #&gt; [1] &quot;PC1&quot; &quot;PC2&quot; &quot;PC3&quot; &quot;PC4&quot; &quot;PC5&quot; &quot;PC6&quot; &quot;PC7&quot; &quot;PC8&quot; &quot;PC9&quot; &quot;PC10&quot; me &lt;- &quot;Florian&quot; glue::glue(&quot;I am {me}&quot;) ## not in base, but so useful #&gt; I am Florian (x &lt;- list.files(pattern = &quot;\\\\.Rmd$&quot;, full.names = TRUE)) #&gt; [1] &quot;./good-practices.Rmd&quot; &quot;./index.Rmd&quot; &quot;./intro.Rmd&quot; #&gt; [4] &quot;./packages.Rmd&quot; &quot;./performance.Rmd&quot; &quot;./presentation_project.Rmd&quot; #&gt; [7] &quot;./rprog.Rmd&quot; &quot;./shiny.Rmd&quot; &quot;./tidyverse.Rmd&quot; sub(&quot;\\\\.Rmd$&quot;, &quot;.pdf&quot;, x) #&gt; [1] &quot;./good-practices.pdf&quot; &quot;./index.pdf&quot; &quot;./intro.pdf&quot; #&gt; [4] &quot;./packages.pdf&quot; &quot;./performance.pdf&quot; &quot;./presentation_project.pdf&quot; #&gt; [7] &quot;./rprog.pdf&quot; &quot;./shiny.pdf&quot; &quot;./tidyverse.pdf&quot; (y &lt;- sample(letters[1:4], 10, replace = TRUE)) #&gt; [1] &quot;d&quot; &quot;d&quot; &quot;c&quot; &quot;b&quot; &quot;d&quot; &quot;a&quot; &quot;d&quot; &quot;c&quot; &quot;c&quot; &quot;a&quot; match(y, letters[1:4]) #&gt; [1] 4 4 3 2 4 1 4 3 3 1 y %in% letters[1:2] #&gt; [1] FALSE FALSE FALSE TRUE FALSE TRUE FALSE FALSE FALSE TRUE split(1:12, rep(letters[1:3], 4)) #&gt; $a #&gt; [1] 1 4 7 10 #&gt; #&gt; $b #&gt; [1] 2 5 8 11 #&gt; #&gt; $c #&gt; [1] 3 6 9 12 intersect(letters[1:4], letters[3:5]) #&gt; [1] &quot;c&quot; &quot;d&quot; union(letters[1:4], letters[3:5]) #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; setdiff(letters[1:4], letters[3:5]) #&gt; [1] &quot;a&quot; &quot;b&quot; 3.4.4 Logical operators TRUE | stop(&quot;will go there&quot;) #&gt; Error in eval(expr, envir, enclos): will go there TRUE || stop(&quot;won&#39;t go there&quot;) ## won&#39;t evaluate second condition if first one is TRUE #&gt; [1] TRUE c(TRUE, FALSE, TRUE, TRUE) &amp; c(FALSE, TRUE, TRUE, FALSE) #&gt; [1] FALSE FALSE TRUE FALSE c(TRUE, FALSE, TRUE, TRUE) &amp;&amp; c(FALSE, TRUE, TRUE, FALSE) ## /!\\ no warning in prior R versions #&gt; Warning in c(TRUE, FALSE, TRUE, TRUE) &amp;&amp; c(FALSE, TRUE, TRUE, FALSE): &#39;length(x) = 4 &gt; 1&#39; #&gt; in coercion to &#39;logical(1)&#39; #&gt; Warning in c(TRUE, FALSE, TRUE, TRUE) &amp;&amp; c(FALSE, TRUE, TRUE, FALSE): &#39;length(x) = 4 &gt; 1&#39; #&gt; in coercion to &#39;logical(1)&#39; #&gt; [1] FALSE (x &lt;- rnorm(10)) #&gt; [1] 1.0241334 -1.3919671 0.6136357 -0.2580564 3.9618835 -0.6024592 0.4113845 #&gt; [8] -0.6672302 0.2135390 1.4710838 ifelse(x &gt; 0, x, -x) # try to find two other equivalents #&gt; [1] 1.0241334 1.3919671 0.6136357 0.2580564 3.9618835 0.6024592 0.4113845 0.6672302 #&gt; [9] 0.2135390 1.4710838 Beware with ifelse() (learn more there), for example ifelse(FALSE, 0, 1:5) #&gt; [1] 1 `if`(FALSE, 0, 1:5) #&gt; [1] 1 2 3 4 5 if (FALSE) 0 else 1:5 #&gt; [1] 1 2 3 4 5 3.4.5 Exercises Use sample(), rep_len() and split() to make a function that randomly splits some indices in a list of K groups of indices (like for cross-validation). [Which are the special cases that you should consider?] advr38pkg::split_ind(1:40, 3) #&gt; $`1` #&gt; [1] 5 11 14 16 18 20 21 23 25 26 29 30 34 39 #&gt; #&gt; $`2` #&gt; [1] 2 3 4 6 7 8 10 12 17 24 32 36 38 #&gt; #&gt; $`3` #&gt; [1] 1 9 13 15 19 22 27 28 31 33 35 37 40 Use replicate() and sample() to get a 95% confidence interval (using bootstrapping) for the mean of the following vector: set.seed(1) (x &lt;- rnorm(10)) #&gt; [1] -0.6264538 0.1836433 -0.8356286 1.5952808 0.3295078 -0.8204684 0.4874291 #&gt; [8] 0.7383247 0.5757814 -0.3053884 mean(x) #&gt; [1] 0.1322028 Expected output (approximately): #&gt; 2.5% 97.5% #&gt; -0.3145143 0.5998608 Use match() and some special accessor to add a column “my_val” to this data my_mtcars by putting the corresponding value of the column specified in “my_col”. [Can your solution be used for any number of column names?] my_mtcars &lt;- mtcars[c(&quot;mpg&quot;, &quot;hp&quot;)] my_mtcars$my_col &lt;- sample(c(&quot;mpg&quot;, &quot;hp&quot;), size = nrow(my_mtcars), replace = TRUE) head(my_mtcars) #&gt; mpg hp my_col #&gt; Mazda RX4 21.0 110 mpg #&gt; Mazda RX4 Wag 21.0 110 mpg #&gt; Datsun 710 22.8 93 hp #&gt; Hornet 4 Drive 21.4 110 hp #&gt; Hornet Sportabout 18.7 175 mpg #&gt; Valiant 18.1 105 hp Expected result (head): #&gt; mpg hp my_col my_val #&gt; Mazda RX4 21.0 110 mpg 21.0 #&gt; Mazda RX4 Wag 21.0 110 mpg 21.0 #&gt; Datsun 710 22.8 93 hp 93 #&gt; Hornet 4 Drive 21.4 110 hp 110 #&gt; Hornet Sportabout 18.7 175 mpg 18.7 #&gt; Valiant 18.1 105 hp 105 In the following data frame (recall that a data frame is also a list), for the first 3 columns, replace letters by corresponding numbers based on the code: df &lt;- data.frame( id1 = c(&quot;a&quot;, &quot;f&quot;, &quot;a&quot;), id2 = c(&quot;b&quot;, &quot;e&quot;, &quot;e&quot;), id3 = c(&quot;c&quot;, &quot;d&quot;, &quot;f&quot;), inter = c(7.343, 2.454, 3.234), stringsAsFactors = FALSE ) df #&gt; id1 id2 id3 inter #&gt; 1 a b c 7.343 #&gt; 2 f e d 2.454 #&gt; 3 a e f 3.234 (code &lt;- setNames(1:6, letters[1:6])) #&gt; a b c d e f #&gt; 1 2 3 4 5 6 Expected result: #&gt; id1 id2 id3 inter #&gt; 1 1 2 3 7.343 #&gt; 2 6 5 4 2.454 #&gt; 3 1 5 6 3.234 3.5 Environments and scoping Lexical scoping determines where to look for values, not when to look for them. R looks for values when the function is run, not when it’s created. This means that the output of a function can be different depending on objects outside its environment: h &lt;- function() { x &lt;- 10 f &lt;- function() { x + 1 } f() } x &lt;- 100 h() #&gt; [1] 11 Variable x is not defined inside f so R will look at the environment of f (where f was defined) and then at the parent environment, and so on. Here, the first x that is found has value 10. Be aware that for functions, packages environments are checked last so that you can redefine functions without noticing. c &lt;- function(...) paste0(...) c(1, 2, 3) #&gt; [1] &quot;123&quot; base::c(1, 2, 3) ## you need to explicit the package #&gt; [1] 1 2 3 rm(c) ## remove the new function from the environment c(1, 2, 3) #&gt; [1] 1 2 3 You can use the &lt;&lt;- operator to change the value of an object in an upper environment: count1 &lt;- 0 count2 &lt;- 0 f &lt;- function(i) { count1 &lt;- count1 + 1 ## will assign a new (temporary) count1 each time count2 &lt;&lt;- count2 + 1 ## will increment count2 on top i + 1 } sapply(1:10, f) #&gt; [1] 2 3 4 5 6 7 8 9 10 11 c(count1, count2) #&gt; [1] 0 10 Finally, how does ... work? Basically, you copy and paste what is put in ...: f1 &lt;- function(...) { list(...) } f1(a = 2, b = 3) #&gt; $a #&gt; [1] 2 #&gt; #&gt; $b #&gt; [1] 3 list(a = 2, b = 3) #&gt; $a #&gt; [1] 2 #&gt; #&gt; $b #&gt; [1] 3 Learn more about functions and scoping rules of R with the R Programming for Data Science book. 3.6 Attributes and classes Attributes are metadata associated with an object. You can get/set the list of attributes with attributes() or one particular attribute with attr(). attributes(iris) #&gt; $names #&gt; [1] &quot;Sepal.Length&quot; &quot;Sepal.Width&quot; &quot;Petal.Length&quot; &quot;Petal.Width&quot; &quot;Species&quot; #&gt; #&gt; $class #&gt; [1] &quot;data.frame&quot; #&gt; #&gt; $row.names #&gt; [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #&gt; [29] 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #&gt; [ reached getOption(&quot;max.print&quot;) -- omitted 100 entries ] class(iris) #&gt; [1] &quot;data.frame&quot; attr(iris, &quot;row.names&quot;) #&gt; [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #&gt; [29] 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #&gt; [ reached getOption(&quot;max.print&quot;) -- omitted 100 entries ] You can use structure() to create an object and add some arbitrary attributes. structure(1:10, my_fancy_attribute = &quot;blabla&quot;) #&gt; [1] 1 2 3 4 5 6 7 8 9 10 #&gt; attr(,&quot;my_fancy_attribute&quot;) #&gt; [1] &quot;blabla&quot; There are also some attributes with specific accessor functions to get and set values. For example, use names(x), dim(x) and class(x) instead of attr(x, \"names\"), attr(x, \"dim\") and attr(x, \"class\"). class(mylm &lt;- lm(Sepal.Length ~ ., data = iris)) #&gt; [1] &quot;lm&quot; I’ve just fitted a linear model in order to predict the sepal length variable of the iris dataset based on the other variables. Using lm() gets me an object of class lm. What are the methods I can use for this object? methods(class = class(mylm)) #&gt; [1] add1 alias anova case.names coerce #&gt; [6] confint cooks.distance deviance dfbeta dfbetas #&gt; [11] drop1 dummy.coef effects extractAIC family #&gt; [16] formula hatvalues influence initialize kappa #&gt; [21] labels logLik model.frame model.matrix nobs #&gt; [26] plot predict print proj qr #&gt; [31] residuals rstandard rstudent show simulate #&gt; [36] slotsFromS3 summary variable.names vcov #&gt; see &#39;?methods&#39; for accessing help and source code summary(mylm) #&gt; #&gt; Call: #&gt; lm(formula = Sepal.Length ~ ., data = iris) #&gt; #&gt; Residuals: #&gt; Min 1Q Median 3Q Max #&gt; -0.79424 -0.21874 0.00899 0.20255 0.73103 #&gt; #&gt; Coefficients: #&gt; Estimate Std. Error t value Pr(&gt;|t|) #&gt; (Intercept) 2.17127 0.27979 7.760 1.43e-12 *** #&gt; Sepal.Width 0.49589 0.08607 5.761 4.87e-08 *** #&gt; Petal.Length 0.82924 0.06853 12.101 &lt; 2e-16 *** #&gt; Petal.Width -0.31516 0.15120 -2.084 0.03889 * #&gt; Speciesversicolor -0.72356 0.24017 -3.013 0.00306 ** #&gt; Speciesvirginica -1.02350 0.33373 -3.067 0.00258 ** #&gt; --- #&gt; Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 #&gt; #&gt; Residual standard error: 0.3068 on 144 degrees of freedom #&gt; Multiple R-squared: 0.8673, Adjusted R-squared: 0.8627 #&gt; F-statistic: 188.3 on 5 and 144 DF, p-value: &lt; 2.2e-16 plot(mylm) R has the easiest way to create a class and to use methods on objects of this class; it is called S3. If you want to know more about the other types of classes, see the Advanced R book. agent007 &lt;- list(first = &quot;James&quot;, last = &quot;Bond&quot;) agent007 #&gt; $first #&gt; [1] &quot;James&quot; #&gt; #&gt; $last #&gt; [1] &quot;Bond&quot; class(agent007) &lt;- &quot;Person&quot; ## &quot;agent007&quot; is now an object of class &quot;Person&quot; # Just make a function called &lt;method_name&gt;.&lt;class_name&gt;() print.Person &lt;- function(x) { print(glue::glue(&quot;My name is {x$last}, {x$first} {x$last}.&quot;)) invisible(x) } agent007 #&gt; My name is Bond, James Bond. # Constructor of class as simple function Person &lt;- function(first, last) { structure(list(first = first, last = last), class = &quot;Person&quot;) } (me &lt;- Person(&quot;Florian&quot;, &quot;Privé&quot;)) #&gt; My name is Privé, Florian Privé. An object can have many classes: Worker &lt;- function(first, last, job) { obj &lt;- Person(first, last) obj$job &lt;- job class(obj) &lt;- c(&quot;Worker&quot;, class(obj)) obj } print.Worker &lt;- function(x) { print.Person(x) print(glue::glue(&quot;I am a {x$job}.&quot;)) invisible(x) } (worker_007 &lt;- Worker(&quot;James&quot;, &quot;Bond&quot;, &quot;secret agent&quot;)) #&gt; My name is Bond, James Bond. #&gt; I am a secret agent. (worker_me &lt;- Worker(&quot;Florian&quot;, &quot;Privé&quot;, &quot;researcher&quot;)) #&gt; My name is Privé, Florian Privé. #&gt; I am a researcher. "],["tidyverse.html", "Chapter 4 Data analysis with the tidyverse 4.1 Program 4.2 Other chapters from this book 4.3 Other resources 4.4 Other “tidy” packages", " Chapter 4 Data analysis with the tidyverse The tidyverse is an opinionated collection of R packages designed for data science. All packages share an underlying design philosophy, grammar, and data structures. For learning how to do data analysis from importing data and tidying it to analyzing it and reporting results, we will use book R for Data Science. You can find most of the exercise solutions there. 4.1 Program my {R Markdown} presentation (also see https://r4ds.had.co.nz/r-markdown.html) my {ggplot2} presentation + exercises from data visualization with {ggplot2} tibbles data transformation with {dplyr} tidy data will rationalize the concept of “tidy” data that is used in the tidyverse and that is easier to work with relational data will give you tools to join information from several datasets more if time allows it (see below) 4.2 Other chapters from this book The other chapters of R for Data Science book are very interesting and you should read them. Unfortunately, we won’t have time to cover them in class. A brief introduction of what you could learn: data import will give you tools to import data (e.g. as a replacement of read.table) strings will help you work with strings and regular expressions factors will help you work with factors dates and times will help you work with dates and times many models will introduce the concept of list-columns that enable you to store complex objects in a structured way inside a data frame databases: packages {DBI} and {dbplyr} + RStudio’s webpage 4.3 Other resources [IN FRENCH] introduction à R et au tidyverse package {tidylog} provides verbose feedback about {dplyr} and {tidyr} operations comparing dplyr functions to their base R equivalents summarize and mutate multiple columns why use purrr::map instead of lapply? reorder those bars the lesser known stars of the tidyverse summary statistics of variables live data analysis by Hadley 4.4 Other “tidy” packages analysis of text data: package {tidytext} with the associated book, analysis of financial data: package {tidyquant}, analysis of time series data: package {tidytime}, a collection of packages for modeling and machine learning using tidyverse principles: package {tidymodels}, a tidy API for graph manipulation: package {tidygraph}, many other packages.. "],["performance.html", "Chapter 5 Performance 5.1 R’s memory management 5.2 Early advice 5.3 Vectorization 5.4 Rcpp 5.5 Linear algebra 5.6 Algorithms &amp; data structures 5.7 Exercises 5.8 Parallel computing", " Chapter 5 Performance Some resources used here or for further reading: Advanced R Efficient R programming The people who say that “R is just always slow” are usually not great R programmers. It is true that writing inefficient R code is easy, yet writing efficient R code is also possible when you know what you’re doing. In this chapter, you will learn how to write R(cpp) code that is fast. 5.1 R’s memory management Read more with this chapter of Advanced R. 5.1.1 Understanding binding basics x &lt;- c(1, 2, 3) It’s creating an object, a vector of values, c(1, 2, 3). And it’s binding that object to a name, x. y &lt;- x There are now two names for the same object in memory. 5.1.2 Copy-on-modify x &lt;- c(1, 2, 3) y &lt;- x y[3] &lt;- 4 x #&gt; [1] 1 2 3 The object in memory is copied before being modified, so that x is not modified. 5.1.3 Copy-on-modify: what about inside functions? f &lt;- function(a) { a } x &lt;- c(1, 2, 3) z &lt;- f(x) f2 &lt;- function(a) { a[1] &lt;- 10 a } z2 &lt;- f2(x) cbind(x, z2) #&gt; x z2 #&gt; [1,] 1 10 #&gt; [2,] 2 2 #&gt; [3,] 3 3 The input parameter is not modified; you operate on a local copy of a = x in f2(). 5.1.4 Lists It’s not just names (i.e. variables) that point to values; elements of lists do too. l1 &lt;- list(1, 2, 3) l2 &lt;- l1 5.1.5 Copy-on-modify for lists? l2[[3]] &lt;- 4 Only the third element needs to be copied. 5.1.6 Data frames Data frames are lists of vectors. d1 &lt;- data.frame(x = c(1, 5, 6), y = c(2, 4, 3)) d2 &lt;- d1 d2[, 2] &lt;- d2[, 2] * 2 # modify one column d3 &lt;- d1 d3[1, ] &lt;- d3[1, ] * 3 # modify one row By modifying the first row, you’re modifying the first element of all vectors, therefore the full data frame is copied.. 5.2 Early advice 5.2.1 NEVER GROW A VECTOR Example computing the cumulative sums of a vector: x &lt;- rnorm(2e4) # Try also with n = 1e5 system.time({ current_sum &lt;- 0 res &lt;- c() for (x_i in x) { current_sum &lt;- current_sum + x_i res &lt;- c(res, current_sum) } }) #&gt; user system elapsed #&gt; 0.52 0.37 0.91 Here, at each iteration, you are reallocating a vector (of increasing size). Not only computations take time, memory allocations do too. This makes your code quadratic with the size of x (if you multiply the size of x by 2, you can expect the execution time to be multiplied by 4, for large sample sizes), whereas it should be only linear. What happens is similar to if you would like to climb these stairs, you climb one stair, go to the bottom, then climb two stairs, go to bottom, climb three, and so on. That takes way more time than just climbing all stairs at once. A good solution is to always pre-allocate your results (if you know the size): system.time({ current_sum &lt;- 0 res2 &lt;- double(length(x)) for (i in seq_along(x)) { current_sum &lt;- current_sum + x[i] res2[i] &lt;- current_sum } }) #&gt; user system elapsed #&gt; 0 0 0 all.equal(res2, res) #&gt; [1] TRUE If you don’t know the size of the results, you can store them in a list and merge them afterwards: system.time({ current_sum &lt;- 0 res3 &lt;- list() for (i in seq_along(x)) { current_sum &lt;- current_sum + x[i] res3[[i]] &lt;- current_sum } }) #&gt; user system elapsed #&gt; 0.02 0.00 0.01 all.equal(unlist(res3), res) #&gt; [1] TRUE With recent versions of R (&gt;= 3.4), you can efficiently grow a vector using system.time({ current_sum &lt;- 0 res4 &lt;- c() for (i in seq_along(x)) { current_sum &lt;- current_sum + x[i] res4[i] &lt;- current_sum } }) #&gt; user system elapsed #&gt; 0 0 0 all.equal(res4, res) #&gt; [1] TRUE Assigning to an element of a vector beyond the current length now over-allocates by a small fraction. The new vector is marked internally as growable, and the true length of the new vector is stored in the truelength field. This makes building up a vector result by assigning to the next element beyond the current length more efficient, though pre-allocating is still preferred. The implementation is subject to change and not intended to be used in packages at this time. (NEWS) An even better solution would be to avoid the loop by using a vectorized function: system.time(res5 &lt;- cumsum(x)) #&gt; user system elapsed #&gt; 0 0 0 all.equal(res5, res) #&gt; [1] TRUE x &lt;- rnorm(1e7) system.time(cumsum(x)) #&gt; user system elapsed #&gt; 0.08 0.00 0.08 As a second example, let us generate a matrix of uniform values (max changing for every column): n &lt;- 1e3 max &lt;- 1:1000 system.time({ mat &lt;- NULL for (m in max) { mat &lt;- cbind(mat, runif(n, max = m)) } }) #&gt; user system elapsed #&gt; 0.67 0.55 1.25 apply(mat, 2, max)[1:10] #&gt; [1] 0.9995517 1.9990569 2.9973087 3.9971285 4.9972705 5.9993567 6.9910700 7.9720831 #&gt; [9] 8.9855022 9.9890691 Instead, we should pre-allocate a matrix of the right size: system.time({ mat3 &lt;- matrix(0, n, length(max)) for (i in seq_along(max)) { mat3[, i] &lt;- runif(n, max = max[i]) } }) #&gt; user system elapsed #&gt; 0.05 0.00 0.05 apply(mat3, 2, max)[1:10] #&gt; [1] 0.9998887 1.9966502 2.9944519 3.9954697 4.9952371 5.9965820 6.9898207 7.9840037 #&gt; [9] 8.9945157 9.9982988 Or we could use a list instead. What is nice with using a list is that you don’t need to pre-allocate. Indeed, as opposed to atomic vectors, each element of a list is in different places in memory so that you don’t have to reallocate all the data when you add an element to a list. system.time({ l &lt;- list() for (i in seq_along(max)) { l[[i]] &lt;- runif(n, max = max[i]) } mat4 &lt;- do.call(&quot;cbind&quot;, l) }) #&gt; user system elapsed #&gt; 0.05 0.00 0.05 apply(mat4, 2, max)[1:10] #&gt; [1] 0.9997514 1.9981741 2.9956951 3.9999324 4.9978970 5.9978088 6.9935050 7.9913796 #&gt; [9] 8.9941795 9.9920729 Instead of pre-allocating yourself, you can use sapply (or lapply and calling do.call() after, as previously done): system.time( mat4 &lt;- sapply(max, function(m) runif(n, max = m)) ) #&gt; user system elapsed #&gt; 0.03 0.00 0.03 apply(mat4, 2, max)[1:10] #&gt; [1] 0.9981629 1.9998850 2.9979426 3.9997915 4.9958974 5.9943567 6.9984283 7.9892951 #&gt; [9] 8.9946816 9.9940610 Don’t listen to people telling you that sapply() is a vectorized operation that is so much faster than loops. That’s false, and for-loops can actually be much faster than sapply() when using just-in-time (JIT) compilation. You can learn more with this blog post. 5.2.2 Use the right function Often, in order to optimize your code, you can simply find the right function to do what you need to do. For example, rowMeans(x) is much faster than apply(x, 1, mean). Similarly, if you want more efficient functions that apply to rows and columns of matrices, you can check package {matrixStats}. Another example is when reading large text files; in such cases, prefer using data.table::fread() rather than read.table(). Generally, packages that uses C/Rcpp are efficient. 5.2.3 Do not try to optimize everything “Programmers waste enormous amounts of time thinking about, or worrying about, the speed of noncritical parts of their programs, and these attempts at efficiency actually have a strong negative impact when debugging and maintenance are considered.” — Donald Knuth. If you try to optimize each and every part of your code, you will end up losing a lot of time writing it, and it will probably make your code less readable. R is great at prototyping quickly because you can write code in a concise and easy way. Start by doing just that. If performance matters, then profile your code to see which part of your code is taking too much time and optimize only this part! Learn more on how to profile your code in RStudio in this article. 5.3 Vectorization I call vectorized a function that takes vectors as arguments and operate on each element of these vectors in another (compiled) language (such as C, C++ and Fortran). Again, sapply() is not a vectorized function (cf. above). Take this code: N &lt;- 10e3; x &lt;- runif(N); y &lt;- rnorm(N) res &lt;- double(length(x)) for (i in seq_along(x)) { res[i] &lt;- x[i] + y[i] } As an interpreted language, for each iteration res[i] &lt;- x[i] + y[i], R has to ask: what is the type of x[i] and y[i]? can I add these two types? what is the type of x[i] + y[i] then? can I store this result in res or do I need to convert it? These questions must be answered for each iteration, which takes time. Some of this is alleviated by JIT compilation. On the contrary, for vectorized functions, these questions must be answered only once, which saves a lot of time. Read more with Noam Ross’s blog post on vectorization. 5.3.1 Exercise Monte-Carlo integration (example from book Efficient R programming) Suppose we wish to estimate the integral \\(\\int_0^1 x^2 dx\\) using a Monte-Carlo method. Essentially, we throw darts at the curve and count the number of darts that fall below the curve (as in the following figure). Monte Carlo Integration pseudo-code Initialize: hits = 0 for i in 1:N \\(~~\\) Generate two random numbers, \\(U_1\\) and \\(U_2\\), between 0 and 1 \\(~~\\) If \\(U_2 &lt; U_1^2\\), then hits = hits + 1 end for Area estimate = hits / N Naively implementing this Monte-Carlo algorithm in R would typically lead to something like: monte_carlo &lt;- function(N) { hits &lt;- 0 for (i in seq_len(N)) { u1 &lt;- runif(1) u2 &lt;- runif(1) if (u1 ^ 2 &gt; u2) { hits &lt;- hits + 1 } } hits / N } This takes a few seconds for N = 1e6: N &lt;- 1e6 system.time(monte_carlo(N)) #&gt; user system elapsed #&gt; 2.96 1.31 4.33 Your task: find a vectorized solution for this problem: system.time(monte_carlo_vec(N)) #&gt; user system elapsed #&gt; 0.06 0.00 0.06 5.4 Rcpp See this presentation. You have this data and this working code (a loop) that is slow mydf &lt;- readRDS(system.file(&quot;extdata/one-million.rds&quot;, package = &quot;advr38pkg&quot;)) QRA_3Dmatrix &lt;- array(0, dim = c(max(mydf$ID), max(mydf$Volume), 2)) for (i in seq_len(nrow(mydf))) { # Row corresponds to the ID class row &lt;- mydf$ID[i] # Column corresponds to the volume class column &lt;- mydf$Volume[i] # Number of events, initially zero, then +1 QRA_3Dmatrix[row, column, 1] &lt;- QRA_3Dmatrix[row, column, 1] + 1 # Sum energy QRA_3Dmatrix[row, column, 2] &lt;- QRA_3Dmatrix[row, column, 2] + 1 - 1.358 / (1 + exp( (1000 * mydf$Energy[i] - 129000) / 120300 )) } Rewrite this for-loop with Rcpp. You can also try to use {dplyr} for this problem. 5.5 Linear algebra In R, prefer using crossprod(X) and tcrossprod(X) instead of t(X) %*% X and X %*% t(X). Also using A %*% (B %*% y) and solve(A, y) will be faster than A %*% B %*% y and solve(A) %*% y. Don’t re-implement linear algebra operations (such as matrix products) yourself. There exist some highly optimized libraries for this. If you want to use linear algebra in Rcpp, try RcppArmadillo or RcppEigen. If you want to use some optimized multi-threaded linear library, you can try Microsoft R Open. 5.5.1 Exercises Compute the Euclidean distances between each of row of X and each row of Y: set.seed(1) X &lt;- matrix(rnorm(1000), ncol = 5) Y &lt;- matrix(rnorm(5000), ncol = 5) A naive implementation would be: system.time({ dist &lt;- matrix(NA_real_, nrow(X), nrow(Y)) for (i in seq_len(nrow(X))) { for (j in seq_len(nrow(Y))) { dist[i, j] &lt;- sqrt(sum((X[i, ] - Y[j, ])^2)) } } }) #&gt; user system elapsed #&gt; 0.22 0.03 0.25 Try first to remove one of the two loops using sweep() instead. Then, try to implement a fully vectorized solution based on this hint: \\(\\text{dist}(X_i, Y_j)^2 = (X_i - Y_j)^T (X_i - Y_j) = X_i^T X_i + Y_j^T Y_j - 2 X_i^T Y_j\\). A faster possible solution takes #&gt; user system elapsed #&gt; 0 0 0 5.6 Algorithms &amp; data structures Sometimes, getting the right data structure (e.g. using a matrix instead of a data frame or integers instead of characters) can save you some computation time. Is your algorithm doing some redundant computations making it e.g. quadratic instead of linear with respect to the dimension of your data? See exercises (section 5.7) for some insights. You can also find a detailed example in this blog post. 5.7 Exercises Generate \\(10^7\\) (start with \\(10^5\\)) steps of the process described by the formula:\\[X(0)=0\\]\\[X(t+1)=X(t)+Y(t)\\] where \\(Y(t)\\) are independent random variables with the distribution \\(N(0,1)\\). Then, calculate the percentage of \\(X(t)\\) that are negative. You do not need to store all values of \\(X\\). A naive implementation with a for-loop could be: set.seed(1) system.time({ N &lt;- 1e5 x &lt;- 0 count &lt;- 0 for (i in seq_len(N)) { y &lt;- rnorm(1) x &lt;- x + y if (x &lt; 0) count &lt;- count + 1 } p &lt;- count / N }) #&gt; user system elapsed #&gt; 0.19 0.06 0.25 p #&gt; [1] 0.88454 Try to vectorize this after having written the value of X(0), X(1), X(2), and X(3). What would be the benefit of writing an Rcpp function over a simple vectorized R function? set.seed(1) system.time(p2 &lt;- advr38pkg::random_walk_neg_prop(1e5)) #&gt; user system elapsed #&gt; 0.00 0.02 0.02 p2 #&gt; [1] 0.88454 set.seed(1) system.time(p3 &lt;- advr38pkg::random_walk_neg_prop(1e7)) #&gt; user system elapsed #&gt; 0.40 0.00 0.41 p3 #&gt; [1] 0.3400444 mat &lt;- as.matrix(mtcars) ind &lt;- seq_len(nrow(mat)) mat_big &lt;- mat[rep(ind, 1000), ] ## 1000 times bigger dataset last_row &lt;- mat_big[nrow(mat_big), ] Speed up these loops (vectorize): system.time({ for (j in 1:ncol(mat_big)) { for (i in 1:nrow(mat_big)) { mat_big[i, j] &lt;- 10 * mat_big[i, j] * last_row[j] } } }) #&gt; user system elapsed #&gt; 0.42 0.00 0.43 Why colSums() on a whole matrix is faster than on only half of it? m0 &lt;- matrix(rnorm(1e6), 1e3, 1e3) microbenchmark::microbenchmark( colSums(m0[, 1:500]), colSums(m0) ) #&gt; Unit: microseconds #&gt; expr min lq mean median uq max neval #&gt; colSums(m0[, 1:500]) 1739.1 1872.60 2178.074 1944.10 2108.10 7202.2 100 #&gt; colSums(m0) 773.5 837.25 887.709 861.75 927.95 1226.3 100 Try to speed up this code by vectorizing it first, and/or by precomputing. Then, recode it in Rcpp and benchmark all the solutions you came up with. M &lt;- 50 step1 &lt;- runif(M) A &lt;- rnorm(M) N &lt;- 1e4 tau &lt;- matrix(0, N + 1, M) tau[1, ] &lt;- A for (j in 1:M) { for (i in 2:nrow(tau)) { tau[i, j] &lt;- tau[i - 1, j] + step1[j] * 1.0025^(i - 2) } } Make a fast function that counts the number of elements between a sequence of breaks. Can you do it in base R? Try also implementing it in Rcpp. How can you implement a solution whose computation time doesn’t depend on the number of breaks? [Which are the special cases that you should consider?] x &lt;- sample(10, size = 1e4, replace = TRUE) breaks &lt;- c(1, 3, 8.5, 9.5, 10) table(cut(x, breaks), exclude = NULL) # does not include first break (1) #&gt; #&gt; (1,3] (3,8.5] (8.5,9.5] (9.5,10] &lt;NA&gt; #&gt; 2006 4970 1027 944 1053 hist(x, breaks, plot = FALSE)$counts # includes first break #&gt; [1] 3059 4970 1027 944 advr38pkg::count_by_breaks(x, breaks) #&gt; [1] 2006 4970 1027 944 advr38pkg::count_by_breaks_fast(x, breaks) #&gt; [1] 2006 4970 1027 944 microbenchmark::microbenchmark( table(cut(x, breaks)), hist(x, breaks, plot = FALSE)$counts, advr38pkg::count_by_breaks(x, breaks, use_outer = TRUE), advr38pkg::count_by_breaks(x, breaks, use_outer = FALSE), advr38pkg::count_by_breaks_fast(x, breaks) ) #&gt; Unit: microseconds #&gt; expr min lq mean median #&gt; table(cut(x, breaks)) 741.7 947.80 1238.794 995.20 #&gt; hist(x, breaks, plot = FALSE)$counts 379.3 414.20 468.615 445.55 #&gt; advr38pkg::count_by_breaks(x, breaks, use_outer = TRUE) 374.0 480.70 527.305 493.10 #&gt; advr38pkg::count_by_breaks(x, breaks, use_outer = FALSE) 207.1 232.95 256.590 242.85 #&gt; advr38pkg::count_by_breaks_fast(x, breaks) 174.8 199.85 224.505 211.55 #&gt; uq max neval #&gt; 1095.60 11724.5 100 #&gt; 492.55 838.7 100 #&gt; 544.15 897.2 100 #&gt; 271.75 384.1 100 #&gt; 238.20 388.9 100 x2 &lt;- sample(100, size = 1e5, replace = TRUE) breaks2 &lt;- breaks * 10 breaks3 &lt;- seq(0, 100, length.out = 100) microbenchmark::microbenchmark( advr38pkg::count_by_breaks(x2, breaks2), advr38pkg::count_by_breaks_fast(x2, breaks2), advr38pkg::count_by_breaks(x2, breaks3), advr38pkg::count_by_breaks_fast(x2, breaks3) ) #&gt; Unit: milliseconds #&gt; expr min lq mean median #&gt; advr38pkg::count_by_breaks(x2, breaks2) 1.3956 1.91115 2.011514 1.98715 #&gt; advr38pkg::count_by_breaks_fast(x2, breaks2) 1.1257 1.53770 1.699999 1.61875 #&gt; advr38pkg::count_by_breaks(x2, breaks3) 28.9796 40.35195 42.392982 41.15070 #&gt; advr38pkg::count_by_breaks_fast(x2, breaks3) 1.1526 1.56035 1.873909 1.63580 #&gt; uq max neval #&gt; 2.10990 10.3615 100 #&gt; 1.71825 9.5968 100 #&gt; 48.57445 54.6974 100 #&gt; 1.76560 10.0074 100 An R user wants to implement some sampling on a sparse matrix and provides this working code: N &lt;- 2000 system.time({ m &lt;- Matrix::Matrix(0, nrow = N, ncol = N) for (j in 1:N) { cols &lt;- sample((1:N)[-j], 2) # pick 2 columns that are not j m[j, cols] &lt;- 1 } }) #&gt; user system elapsed #&gt; 1.76 0.06 1.82 This code is slow; can you find two major reasons why? How can you more efficiently assign 1s? A faster solution would take: #&gt; user system elapsed #&gt; 0.05 0.03 0.08 Can you use sampling with replacement (to avoid unnecessarily allocating memory) in this example? A faster solution would take: #&gt; user system elapsed #&gt; 0.01 0.00 0.02 It would be even faster using Rcpp (cf. this SO answer). Make a fast function that returns all prime numbers up to a number N. N &lt;- 1e6 system.time( primes &lt;- advr38pkg::AllPrimesUpTo(N) ) #&gt; user system elapsed #&gt; 0.05 0.02 0.06 plot(primes, pch = 20, cex = 0.5) 5.8 Parallel computing I basically always use foreach and recommend to do so. See my guide to parallelism in R with foreach. Just remember to optimize your code before trying to parallelize it. Try to parallelize some of your best solutions for the previous exercises. "],["packages.html", "Chapter 6 Packages 6.1 Resources 6.2 Project exercise 6.3 Quick start 6.4 Basic stuff 6.5 Good practices 6.6 More 6.7 Release on CRAN", " Chapter 6 Packages 6.1 Resources R Packages book (read it!) Writing R extensions, the official CRAN guide (easier to read as a bookdown) Look at popular R packages on GitHub Customizing Package Build Options Mastering Software Development in R How to develop good R packages (for open science) How to decide when to trust an R package? 6.2 Project exercise Just to experiment with making an R package, we’ll try to make a small package that implements some of the features of package {dplyr} that we learned in chapter 4. We can call this package {minidplyr}. After having read the following two sections (6.3 and 6.4), create a first function that helps you select variables of a data frame by using a character vector of variable names or an integer vector of variable positions. Which accessor could you use? Document this function and use it. Bonus (for later): can you use base R function subset to use variables names without quoting them? Check your package with Ctrl/Cmd + Shift + E and fix all problems. At this point, there should be no ERROR or WARNING, unless you did not document the previous function properly. However, you should still update the DESCRIPTION file with proper information. Do it, fix any problem, and run checks again. You could submit this package to CRAN in its present form; congratulations on your new R package! Commit everything and push to GitHub. Try to install the package from someone else using remotes::install_github(\"&lt;github-username&gt;/minidplyr\"). Learn how to make unit tests in section 6.5.1 and do that for your new function select2. Which silly cases you should test? Here, you can use usethis::use_package(\"dplyr\", type = \"Suggests\") to add package {dplyr} to the suggested packages (because you will use this package in tests only). You can see the unit tests I came up with for this function. Make a function filter2 that enables to filter rows of a data frame. Add some documentation and tests for this function as well. Learn about continuous checking of your package in section 6.5.2. Follow the instructions, commit and push your changes. Go check your new badges on GitHub! Learn how to make a website out of your package in section 6.5.3 and build one for this package (or another of your packages). Implement more functions if you find this project interesting. For example, make a function mutate2 with the help of base R function transform (or within). Try to make the previous functions more general by taking many arguments at once (in ...). Make sure to keep your existing code as internal functions in order to break your code in manageable parts. 6.3 Quick start In my first package, I just put some functions I used again and again in my work. To quickly start your package, just follow these steps: Create a new RStudio project (not a package). Here, I advise you to create a new project on GitHub (with a README) and then clone it as an RStudio project. It is a good practice to put all your (public) stuff on GitHub (as we learned in section 2.3). Run the following lines of R code. usethis::use_description(list(License = &quot;GPL-3&quot;)) usethis::use_namespace() dir.create(&quot;R&quot;) usethis::use_package_doc() usethis::use_roxygen_md() Restart RStudio and change the following options. You should see a new “Build” panel next to the “Git” panel. Then use Ctrl/Cmd + Shift + B to build and reload your package. Create a simple function and put it in an .R file in the R/ directory. Inside the function, use Code -&gt; Insert Roxygen Skeleton. Build and reload your package and check the documentation of your new function and that you can use it. 6.4 Basic stuff 6.4.1 DESCRIPTION file See this chapter on the DESCRIPTION file. 6.4.2 R code Put your R code in the R/ directory. Basically it would be mostly functions. Don’t use random lines of code like in R scripts. Never explicitly load a package with library() or require(). Use usethis::use_package() to add one package to your DESCRIPTION file. Then, refer to some function with &lt;package&gt;::&lt;function&gt;() in your code, or by using the @import &lt;package&gt; or @importFrom &lt;package&gt; &lt;function&gt; roxygen tags. If one R function need another function in another R file, use the @import &lt;basename&gt;.R to make sure it is built and documented before; it is for example useful if you define new generics and methods in different files. If you modify global options() or graphics par() in a function of your package (try to avoid it), save the old values and reset when you are done: old &lt;- options(stringsAsFactors = FALSE) on.exit(options(old), add = TRUE) 6.4.3 Documentation Documentation is super useful for other people (including future-you, in 6 months when you won’t remember what you implemented in your package). Make sure to document your code as soon as you write it, otherwise you will never do it. Forget about the man/ (manual) directory, files in this directory will be automatically generated thanks to the roxygen comments you use on top of your R functions. Learn more with this chapter. Note that you can now use the Markdown syntax in the documentation. For example, instead of having to use \\code{foo}, you can directly use `foo` in the roxygen comments. To use (and export) functions already implemented in other packages, for example the pipe from package {magrittr}, you can use usethis::use_package(\"magrittr\") and put the following code somewhere in an R file of your package. #&#39; @importFrom magrittr %&gt;% #&#39; @export magrittr::`%&gt;%` Fun: [How to] Include a dancing banana in your R package documentation. 6.4.4 NAMESPACE file You can also forget about this for now because it should be automatically generated by {roxygen}. If you want to understand what’s going on, read this chapter. 6.5 Good practices 6.5.1 Testing You are probably already testing your code, you’re only doing it informally. The problem with this approach is that when you come back to this code in 3 months time to add a new feature, you’ve probably forgotten some of the informal tests you ran the first time around. This makes it very easy to break existing code that used to work (which you should avoid as much as you can). A very good practice is to use unit tests. Read this chapter. To make your first unit tests, use usethis::use_test() while having open the R file you want to test. Write some unit tests, then you can run tests of your package with Ctrl/Cmd + Shift + T. 6.5.2 Continuous checking I would rarely trust a package that doesn’t use these continuous integration services. It’s good practice to check your package regularly and on different Operating Systems (OS). Learn more about the different checks there. An easy way to regularly check your package on GitHub is to use GitHub Actions. Indeed, each time you push to your GitHub repository, checks are run on different OS. To use this service, you can run usethis::use_github_action_check_standard(). To get the coverage of your tests, use Codecov by running usethis::use_coverage() and usethis::use_github_action(\"test-coverage\"). Finally, to prevent typos in your package and especially for non-native English speakers, it can be useful to check the spelling in your package. If you think that the word “programmation” exists and that “prefered” has only one ‘r’ at the end (I did!), you should definitely use package {spelling}. Just run spelling::spell_check_setup(); this will check spelling in your package at the end of checks. If it reports words you want to ignore, just put these words in a text file inst/WORDLIST (with one word by line). 6.5.3 Pkgdown Run usethis::use_pkgdown(). If added, remove docs from the .gitignore file. Run pkgdown:::build_site(). On GitHub, go to the settings of your repo, and enable GitHub Pages from the /docs folder. Push the new files. This will render everything that you have in this folder as a website (after 0-2 minutes). To get more information and especially to configure the website, see the documentation, as a {pkgdown} website, of course. For an example, see the website of my package {bigstatsr} and the corresponding YAML file. If you want to make a personal website, check this quick tutorial. 6.6 More 6.6.1 Rcpp We learned about Rcpp in section 5.4. To use Rcpp code in your package, just use usethis::use_rcpp() and put the 2 roxygen tags e.g. in the file R/&lt;package&gt;-package.R. Then, create .cpp files with RStudio and save them the src/ directory. Note that the // [[Rcpp::export]] makes the C++ function available to R, it doesn’t export the function as part of your package (though you could access it with &lt;package&gt;:::&lt;rcpp-fun&gt;()). If you want your package to explicitly provides an Rcpp function (as an R function), you also need roxygen comments (beginning with //' instead of #', including //' @export) on top of your Rcpp function. If you need some C++ code from another package (e.g. from package {RcppArmadillo}), normally you would use // [[Rcpp::depends(RcppArmadillo)]] #include &lt;RcppArmadillo.h&gt; In an R package, you don’t need the first line but instead you need to add the package to the LinkingTo field of the DESCRIPTION file (e.g. with usethis::use_package(\"RcppArmadillo\", \"LinkingTo\")). 6.6.2 Ignore files There are two types of ignore: Files ignored by Git, specified in the .gitignore file. For example, you don’t want to track changes for some large data files or some binaries often changing. You can ignore files by using usethis::use_git_ignore(). Files ignored during the build of your package, specified in the .Rbuildignore file. For example, in my packages, I generally have two directories called tmp-tests and tmp-save where I just put some random code that I used once during development. Checks will tell you if your package contains non-standard files or directories. Moreover, I generally ignore vignettes; they are still built as part of the {pkgdown} website. There is also a {usethis} function for this: usethis::use_build_ignore(). 6.6.3 The inst/ directory When a package is installed, everything in inst/ is copied into the top-level package directory. For example, you can have: inst/extdata/: additional external data for examples and vignettes. See section 6.6.4 for more detail. You can also use inst/testdata/ for data you need in tests. To access one file in this directory, use system.file(). For example, if you have a file inst/extdata/mydata.csv in your package, an user can find it using system.file(\"extdata\", \"mydata.csv\", package = \"&lt;package&gt;\"). inst/include: some C++ code that others can use by LinkingTo your package. For example, when you use #include &lt;Rcpp.h&gt; at the top of your Rcpp code, you’re using the code in there. inst/CITATION: how to cite the package. Learn more there. 6.6.4 External data Learn more with this book chapter. 6.7 Release on CRAN If you want your package to be on CRAN, read this chapter. "],["shiny.html", "Chapter 7 Shiny 7.1 Example 7.2 DataCamp course 7.3 Other resources", " Chapter 7 Shiny 7.1 Example You see my Shiny App for creating pixel art models. # Installation remotes::install_github(&quot;privefl/pixelart&quot;) # Run Shiny App pixelart::run_pixelart() 7.2 DataCamp course Let us use this free DataCamp course to learn the basics of Shiny. We won’t use DataCamp for this course anymore. See why here. 7.3 Other resources Mastering Shiny Shiny website Shiny gallery Shiny themes Shiny tutorials Shiny dashboards Shiny widgets Advanced Shiny tips JavaScript operations in Shiny Getting Started with Shiny A gradual introduction to Shiny "],["project.html", "Chapter 8 Project 8.1 What is Tidy Tuesday? 8.2 Tidy Thursday", " Chapter 8 Project Either have some idea about new functions you want to create and share, and make it as a new R package, explore, visualize, and analyze some data (cf. hereinafter). 8.1 What is Tidy Tuesday? A weekly data project from the R4DS community. The aim is to understand how to summarize and arrange data to make meaningful charts with ggplot2, tidyr, dplyr, and other tools in the tidyverse ecosystem. Safe and supportive space for individuals to practice their wrangling and data visualization skills independent of drawing conclusions. How it works: The dataset comes from a source article and it is made available on Mondays. People then play with the data set using the tidyverse, explore things that they think are interesting, and/or try to recreate the source article plots/results. And share their own version on Twitter (with the hashtag #TidyTuesday). 8.2 Tidy Thursday Our own mini-version of Tidy Tuesday! Join in teams of 2 (or 3). Choose a dataset from the ones provided. Come up with an interesting topic to visualize (or recreate an existing one). Apply things you have learned in this course, and try to learn new things with our help and Google’s help. Share the resulting plot(s) and the code with the rest on Friday with a short presentation talking about challenges and conclusions from the plot. 8.2.1 Choose a dataset Install the {tidytuesdayR} package: install.packages(&quot;tidytuesdayR&quot;) Some interesting datasets: Olympic medals data &lt;- tidytuesdayR::tt_load(&#39;2021-07-27&#39;)[[&quot;olympics&quot;]] Netflix titles data &lt;- tidytuesdayR::tt_load(&#39;2021-04-20&#39;)[[&quot;netflix_titles&quot;]] Spotify songs data &lt;- tidytuesdayR::tt_load(&#39;2020-01-21&#39;)[[&quot;spotify_songs&quot;]] If you do not like any of these, you can also choose from all the previous tidy Tuesday datasets here. 8.2.2 Visualize the data Come up with a question, or an interesting thing to learn from the data. You can get inspired by looking at other participants on Twitter: Shiny app with a compilation of tweets ordered by likes TidyTuesdayRocks Search for #TidyTuesday + dataset_name on Twitter. Remember that the code is always available at the author’s github page. 8.2.3 Compilation of tweets 8.2.4 Example Someone tried the recreate a plot using the Netflix dataset: In today&#39;s #TidyTuesday I looked at Netflix movies, specifically checking out movie duration over time. #Rstats https://t.co/PeVIhpAsSy pic.twitter.com/2TOZ9nFKQP&mdash; Marieke (@marieke_k_jones) April 20, 2021 Clara’s (quick) version: library(tidyverse) netflix_titles &lt;- tidytuesdayR::tt_load(&#39;2021-04-20&#39;)[[&quot;netflix_titles&quot;]] ## ## Downloading file 1 of 1: `netflix_titles.csv` netflix_titles %&gt;% filter(type == &quot;Movie&quot;) %&gt;% mutate(duration = as.numeric(str_extract(duration, &quot;(\\\\d)+&quot;)), cat = map_chr(listed_in, ~str_split(.x, &quot;, &quot;)[[1]][1]), cat = case_when( cat %in% c(&quot;Horror Movies&quot;, &quot;Thrillers&quot;) ~ &quot;Horror Movies &amp; Thrillers&quot;, TRUE ~ cat)) %&gt;% group_by(release_year, cat) %&gt;% summarise(mean_duration = mean(duration)) %&gt;% filter(cat %in% c(&quot;Action &amp; Adventure&quot;, &quot;Children &amp; Family Movies&quot;, &quot;Comedies&quot;, &quot;Documentaries&quot;, &quot;Dramas&quot;, &quot;Horror Movies &amp; Thrillers&quot;)) %&gt;% ggplot(aes(x = release_year, y = mean_duration, color = cat)) + geom_line() + scale_x_continuous(limits = c(1980, 2020)) + scale_y_continuous(limits = c(50, 160), breaks = seq(50,150, 25)) + facet_wrap(~cat) + theme_minimal() + theme(text = element_text(size = 14), legend.position = &quot;none&quot;, axis.title.x = element_blank()) + labs(title = &quot;Children&#39;s movies and Dramas decrease in duration over time&quot;, y = &quot;Average movie duration (min)&quot;) 8.2.5 Presentation Make a short (5-10 min) presentation; you can simply make an HTML from RMarkdown, push to GitHub and we can preview it on http://htmlpreview.github.io/. What you can present: Introduce the data set and the variables you have chosen to visualize. Show the resulting plot and discuss the trends/patterns in the data. If you chose to recreate a visualization from Twitter, comment on the quality of the plot or potential problems. Show the generative code and comment on the steps and transformations you have applied to the data. Did you find a set of tidyverse functions particularly useful? Did you discover another useful package? Some examples from students in 2022: alcohol consumption lego sets F1 winners baby names a package "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
