[["r-programming.html", "Chapter 3 R programming 3.1 Common mistakes to avoid 3.2 R base objects 3.3 Base objects and accessors 3.4 Useful R base functions 3.5 Environments and scoping 3.6 Attributes and classes 3.7 Summary Useful resources", " Chapter 3 R programming In the following, we will consider base R concepts that are important but often overlooked by or unknown to R users. We hope that this chapter will help you to better understand R as a programming language, to avoid common mistakes, and to write more efficient code. Some of the examples used in this chapter are taken from The R Inferno by Patrick Burns, who described his materials in the following way: If you are using R and you think you’re in hell, this is a map for you. — Patrick Burns 3.1 Common mistakes to avoid In the first part of this chapter, we will look at some common mistakes and how to avoid them. 3.1.1 The floating-point error In R, a real number is represented as a floating-point number. A floating-point number is a positive or negative whole number scaled by an integer exponent of a fixed base. It is actually not that complicated. For example, 12.568 is a floating-point number in base ten with five digits of precision: \\[ 12.568 = \\underbrace{12568}_\\text{whole number} \\times {\\underbrace{10}_\\text{base}}^{\\overbrace{-3}^\\text{integer exponent}} \\] Base ten is the most convenient base to understand how floating-point numbers are represented. But you can use any base. For example, in base five, 12.568 is represented by \\[ 12.568 = \\underbrace{22241}_\\text{whole number} \\times {\\underbrace{5}_\\text{base}}^{\\overbrace{-3}^\\text{integer exponent}}, \\] i.e. a floating-point number with five digits of precision. You can validate that this is indeed the right representation \\[ \\begin{align*} 22241 \\times 5^{-3} &amp;= (2 \\times 5^{4} + 2 \\times 5^{3} + 2 \\times 5^{2} + 4 \\times 5^{1} + 1 \\times 5^{0}) \\times 5^{-3}\\\\ &amp;= 2 \\times 5^{1} + 2 \\times 5^{0} + 2 \\times 5^{-1} + 4 \\times 5^{-2} + 1 \\times 5^{-3}\\\\ &amp;= 10 + 2 + 0,4 + 0,16 + 0.008\\\\ &amp;= 12.568. \\end{align*} \\] In base two, the representation is more complex: \\[ 12.568 = \\underbrace{1100 1001 0001 0110 1000 0111 0010 1011 0000 0010 0000 1100 0100 1001 1011 1010 011}_\\text{whole number} \\times {\\underbrace{2}_\\text{base}}^{\\overbrace{-60}^\\text{integer exponent}}, \\] but it still has the same form; a positive whole number with 64 digits of precision times the base to the power -60. Not all real numbers can be represented by a floating-point number with a predefined precision. The base and the number of digits regulate how precisely a floating point number can be represented. For example, you cannot represent 12.568 as a floating-point number with four digits of precision in base ten, five or two. The nearest whole number of 12586 with only four digits of precision is 1257. Hence, the closest we can get to 12.568 using only four digits of precision in base ten is 12.57. Not too bad. The nearest whole number of 22241 with only four digits of precision is 2224. Therefore, the closest we can get to 12.568 using only four digits of precision in base five is 12.56. A bit worse than in base ten. However, the nearest whole number of 1100100100010110100001110010101100000010000011000100100110111010011 with only four digits of precision in base 2 is 1100. This means that the closest we can get to 12.568 using only four digits of precision in base five is 12. A difference of 0.568 may not be problematic in some cases, but it can be catastrophic in others. R uses base 2 with (usually) 53 digits of precision. Hence, all floating-point numbers with more than 53 digits of precision will be represented by the nearest floating-point number with 53 digits of precision. For example, take the real number 0.3. In base two, 0.3 is represented by 0.0100110011001100110011001100… (a number with infinitely many digits of precision). The nearest floating-point number with only 53 digits of precision is 0.299999999999999988897769753748434595763683319091796875, which is the floating-point number R uses to represent 0.3. The binary representation is not perfect, but it is the best approximation R has. When you assign the value 0.3 to an object and print the object to the console afterwards, you will see that R returns 0.3: x &lt;- 0.3 x #&gt; [1] 0.3 So you may think Why did you bother me with all that talk about floating-point numbers? There is clearly no problem here! However, per default, the function print() only prints 7 significant digits when printing numeric values. getOption(&quot;digits&quot;) #&gt; [1] 7 If you increase that number to 22, you can see that 0.3 is actually represented by 0.2999999999999999888978 print(x, digits = 22) #&gt; [1] 0.2999999999999999888978 This inaccuracy is known as the floating-point error, and it is the reason why simple comparisons like the following can fail: (0.1 + 0.2) == 0.3 #&gt; [1] FALSE Instead of using == to compare two objects, use the base R function all.equal() to test if two objects are equal up to some tolerance (\\(1.5\\times 10^{-8}\\) per default). all.equal(0.1 + 0.2, 0.3) #&gt; [1] TRUE all.equal(0.1 + 0.2, 0.3, tolerance = 0) #&gt; [1] &quot;Mean relative difference: 1.850372e-16&quot; all.equal(0.1 + 0.2, 0.3, tolerance = 1e-16) #&gt; [1] &quot;Mean relative difference: 1.850372e-16&quot; all.equal(0.1 + 0.2, 0.3, tolerance = 1e-15) #&gt; [1] TRUE As all.equal() returns either TRUE or a string with the mean relative difference, you cannot use it directly in if expressions. Use isTRUE(all.equal()) instead: isTRUE(all.equal(0.1 + 0.2, 0.4)) #&gt; [1] FALSE Alternatively, you can use the dplyr function near() dplyr::near(0.1 + 0.2, 0.3) #&gt; [1] TRUE dplyr::near(0.1 + 0.2, 0.3, tol = 1e-17) #&gt; [1] FALSE 3.1.2 Arguments Another source of mistakes is the use of named and unnamed arguments. min(-1, 5, 118) #&gt; [1] -1 max(-1, 5, 118) #&gt; [1] 118 mean(-1, 5, 118) #&gt; [1] -1 median(-1, 5, 118) #&gt; [1] -1 How to explain the issue with mean and median? Let us look at the parameters of these functions: args(max) #&gt; function (..., na.rm = FALSE) #&gt; NULL args(mean) #&gt; function (x, ...) #&gt; NULL args(median) #&gt; function (x, na.rm = FALSE, ...) #&gt; NULL One solution is to always use a vector: min(c(-1, 5, 118)) #&gt; [1] -1 max(c(-1, 5, 118)) #&gt; [1] 118 mean(c(-1, 5, 118)) #&gt; [1] 40.66667 median(c(-1, 5, 118)) #&gt; [1] 5 3.1.3 Others sample(1:10) #&gt; [1] 8 3 2 7 10 9 1 6 4 5 sample(10) #&gt; [1] 1 9 6 2 10 5 8 3 4 7 sample(10.1) #&gt; [1] 1 6 9 10 7 5 2 3 4 8 n &lt;- 10 1:n-1 ## is (1:n) - 1, so 0:(n - 1) #&gt; [1] 0 1 2 3 4 5 6 7 8 9 1:(n-1) #&gt; [1] 1 2 3 4 5 6 7 8 9 seq_len(n - 1) #&gt; [1] 1 2 3 4 5 6 7 8 9 1:0 #&gt; [1] 1 0 seq_len(0) ## prefer using seq_len(n) rather than 1:n (e.g. in for-loops) #&gt; integer(0) seq_along(5:7) ## a shortcut for seq_len(length(.)) #&gt; [1] 1 2 3 3.2 R base objects 3.2.1 Types There are several “atomic” types of data: logical, integer, double and character (in this order, see below). There are also raw and complex, but they are rarely used. You cannot mix types in an atomic vector, but you can in a list. Coercion will automatically occur when you mix types in a vector: (a &lt;- FALSE) #&gt; [1] FALSE typeof(a) #&gt; [1] &quot;logical&quot; (b &lt;- 1:10) #&gt; [1] 1 2 3 4 5 6 7 8 9 10 typeof(b) #&gt; [1] &quot;integer&quot; c(a, b) ## FALSE is coerced to an integer -&gt; 0 #&gt; [1] 0 1 2 3 4 5 6 7 8 9 10 (c &lt;- 10.5) #&gt; [1] 10.5 typeof(c) #&gt; [1] &quot;double&quot; (d &lt;- c(b, c)) ## coerced to numeric #&gt; [1] 1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0 10.0 10.5 c(d, &quot;a&quot;) ## coerced to character #&gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; &quot;10.5&quot; &quot;a&quot; c(list(1), &quot;a&quot;) #&gt; [[1]] #&gt; [1] 1 #&gt; #&gt; [[2]] #&gt; [1] &quot;a&quot; 50 &lt; &quot;7&quot; ## does &quot;50&quot; &lt; &quot;7&quot; #&gt; [1] TRUE 3.2.2 Exercise Use the automatic type coercion to convert this boolean matrix to a numeric one (with 0s and 1s). [What do you need to change in your code to get an integer matrix instead of a numeric one?] (mat &lt;- matrix(sample(c(TRUE, FALSE), 12, replace = TRUE), nrow = 3)) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] TRUE FALSE TRUE TRUE #&gt; [2,] TRUE FALSE FALSE FALSE #&gt; [3,] FALSE TRUE FALSE TRUE 3.3 Base objects and accessors 3.3.1 Objects “atomic” vector: vector of one base type (see above). scalar: this doesn’t exist, this is a vector of length 1. matrices / arrays: a vector with some dimensions (attribute). (vec &lt;- 1:12) #&gt; [1] 1 2 3 4 5 6 7 8 9 10 11 12 dim(vec) &lt;- c(3, 4) vec #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 class(vec) #&gt; [1] &quot;matrix&quot; &quot;array&quot; dim(vec) &lt;- c(3, 2, 2) vec #&gt; , , 1 #&gt; #&gt; [,1] [,2] #&gt; [1,] 1 4 #&gt; [2,] 2 5 #&gt; [3,] 3 6 #&gt; #&gt; , , 2 #&gt; #&gt; [,1] [,2] #&gt; [1,] 7 10 #&gt; [2,] 8 11 #&gt; [3,] 9 12 class(vec) #&gt; [1] &quot;array&quot; list: vector of elements with possibly different types in it. data.frame: a list whose elements have the same lengths, and formatted somewhat as a matrix. head(iris) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 1 5.1 3.5 1.4 0.2 setosa #&gt; 2 4.9 3.0 1.4 0.2 setosa #&gt; 3 4.7 3.2 1.3 0.2 setosa #&gt; 4 4.6 3.1 1.5 0.2 setosa #&gt; 5 5.0 3.6 1.4 0.2 setosa #&gt; 6 5.4 3.9 1.7 0.4 setosa dim(iris) #&gt; [1] 150 5 length(iris) ## a data.frame is also a list #&gt; [1] 5 3.3.2 Accessors The [ accessor is used to access a subset of the data with the same class. (x &lt;- 1:5) #&gt; [1] 1 2 3 4 5 x[2:3] #&gt; [1] 2 3 x[2:8] ## /!\\ no warning #&gt; [1] 2 3 4 5 NA NA NA (y &lt;- matrix(1:12, nrow = 3)) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 y[4:9] ## a matrix is also a vector #&gt; [1] 4 5 6 7 8 9 (l &lt;- list(a = 1, b = &quot;I love R&quot;, c = matrix(1:6, nrow = 2))) #&gt; $a #&gt; [1] 1 #&gt; #&gt; $b #&gt; [1] &quot;I love R&quot; #&gt; #&gt; $c #&gt; [,1] [,2] [,3] #&gt; [1,] 1 3 5 #&gt; [2,] 2 4 6 l[2:3] #&gt; $b #&gt; [1] &quot;I love R&quot; #&gt; #&gt; $c #&gt; [,1] [,2] [,3] #&gt; [1,] 1 3 5 #&gt; [2,] 2 4 6 head(iris) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 1 5.1 3.5 1.4 0.2 setosa #&gt; 2 4.9 3.0 1.4 0.2 setosa #&gt; 3 4.7 3.2 1.3 0.2 setosa #&gt; 4 4.6 3.1 1.5 0.2 setosa #&gt; 5 5.0 3.6 1.4 0.2 setosa #&gt; 6 5.4 3.9 1.7 0.4 setosa head(iris[3:4]) #&gt; Petal.Length Petal.Width #&gt; 1 1.4 0.2 #&gt; 2 1.4 0.2 #&gt; 3 1.3 0.2 #&gt; 4 1.5 0.2 #&gt; 5 1.4 0.2 #&gt; 6 1.7 0.4 class(iris[5]) #&gt; [1] &quot;data.frame&quot; You can also use a logical and character vectors to index these objects. (x &lt;- 1:4) #&gt; [1] 1 2 3 4 x[c(FALSE, TRUE, FALSE, TRUE)] #&gt; [1] 2 4 x[c(FALSE, TRUE)] ## logical vectors are recycled #&gt; [1] 2 4 head(iris[c(&quot;Petal.Length&quot;, &quot;Species&quot;)]) #&gt; Petal.Length Species #&gt; 1 1.4 setosa #&gt; 2 1.4 setosa #&gt; 3 1.3 setosa #&gt; 4 1.5 setosa #&gt; 5 1.4 setosa #&gt; 6 1.7 setosa The [[ accessor is used to access a single element. (x &lt;- 1:10) #&gt; [1] 1 2 3 4 5 6 7 8 9 10 x[[3]] #&gt; [1] 3 l[[2]] #&gt; [1] &quot;I love R&quot; iris[[&quot;Species&quot;]] #&gt; [1] setosa setosa setosa setosa setosa setosa setosa #&gt; [8] setosa setosa setosa setosa setosa setosa setosa #&gt; [15] setosa setosa setosa setosa setosa setosa setosa #&gt; [22] setosa setosa setosa setosa setosa setosa setosa #&gt; [29] setosa setosa setosa setosa setosa setosa setosa #&gt; [36] setosa setosa setosa setosa setosa setosa setosa #&gt; [43] setosa setosa setosa setosa setosa setosa setosa #&gt; [50] setosa versicolor versicolor versicolor versicolor versicolor versicolor #&gt; [57] versicolor versicolor versicolor versicolor versicolor versicolor versicolor #&gt; [64] versicolor versicolor versicolor versicolor versicolor versicolor versicolor #&gt; [71] versicolor versicolor versicolor versicolor versicolor versicolor versicolor #&gt; [78] versicolor versicolor versicolor versicolor versicolor versicolor versicolor #&gt; [85] versicolor versicolor versicolor versicolor versicolor versicolor versicolor #&gt; [92] versicolor versicolor versicolor versicolor versicolor versicolor versicolor #&gt; [99] versicolor versicolor virginica virginica virginica virginica virginica #&gt; [106] virginica virginica virginica virginica virginica virginica virginica #&gt; [113] virginica virginica virginica virginica virginica virginica virginica #&gt; [120] virginica virginica virginica virginica virginica virginica virginica #&gt; [127] virginica virginica virginica virginica virginica virginica virginica #&gt; [134] virginica virginica virginica virginica virginica virginica virginica #&gt; [141] virginica virginica virginica virginica virginica virginica virginica #&gt; [148] virginica virginica virginica #&gt; Levels: setosa versicolor virginica Figure 3.1: Indexing lists in R. [Source: https://goo.gl/8UkcHq] Beware partial matching x &lt;- list(aardvark = 1:5) x$a #&gt; [1] 1 2 3 4 5 x[[&quot;a&quot;]] #&gt; NULL x[[&quot;a&quot;, exact = FALSE]] #&gt; [1] 1 2 3 4 5 Special use of the [ accessor for array-like data. (mat &lt;- matrix(1:12, 3)) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 mat[1, ] #&gt; [1] 1 4 7 10 mat[, 1:2] #&gt; [,1] [,2] #&gt; [1,] 1 4 #&gt; [2,] 2 5 #&gt; [3,] 3 6 mat[1, 1:2] #&gt; [1] 1 4 mat[1, 1:2, drop = FALSE] #&gt; [,1] [,2] #&gt; [1,] 1 4 (two_col_ind &lt;- cbind(c(1, 3, 2), c(1, 4, 2))) #&gt; [,1] [,2] #&gt; [1,] 1 1 #&gt; [2,] 3 4 #&gt; [3,] 2 2 mat[two_col_ind] #&gt; [1] 1 12 5 mat[] #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 mat[] &lt;- 2 mat #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 2 2 2 2 #&gt; [2,] 2 2 2 2 #&gt; [3,] 2 2 2 2 If you use arrays with more than two dimensions, simply add an additional comma for every new dimension. 3.3.3 Exercises Use the dimension attribute to make a function that computes the sums every n elements of a vector. In which order are matrix elements stored? [Which are the special cases that you should consider?] advr38pkg::sum_every(1:10, 2) #&gt; [1] 3 7 11 15 19 Compute the means of every numeric columns of the iris dataset. Expected result: #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width #&gt; 5.843333 3.057333 3.758000 1.199333 Convert the following matrix to a vector by replacing (0, 0) -&gt; 0; (0, 1) -&gt; 1; (1, 1) -&gt; 2; (1, 0) -&gt; NA. mat &lt;- matrix(0, 10, 2); mat[c(5, 8, 9, 12, 15, 16, 17, 19)] &lt;- 1; mat #&gt; [,1] [,2] #&gt; [1,] 0 0 #&gt; [2,] 0 1 #&gt; [3,] 0 0 #&gt; [4,] 0 0 #&gt; [5,] 1 1 #&gt; [6,] 0 1 #&gt; [7,] 0 1 #&gt; [8,] 1 0 #&gt; [9,] 1 1 #&gt; [10,] 0 0 by using this matrix: (decode &lt;- matrix(c(0, NA, 1, 2), 2)) #&gt; [,1] [,2] #&gt; [1,] 0 1 #&gt; [2,] NA 2 Start by doing it for one row, then by using apply(), finally replace it by a special accessor; what is the benefit? Expected result: #&gt; [1] 0 1 0 0 2 1 1 NA 2 0 3.4 Useful R base functions In this section, I present some useful R base functions (also see this comprehensive list in French and this one in English): 3.4.1 General # To get some help ?topic # Run code from the example section example(sum) # Structure overview str(iris) ## skimr::skim(iris) is also very useful #&gt; &#39;data.frame&#39;: 150 obs. of 5 variables: #&gt; $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... #&gt; $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... #&gt; $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... #&gt; $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... #&gt; $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... # List objects in the environment ls() #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;decode&quot; &quot;l&quot; #&gt; [7] &quot;mat&quot; &quot;n&quot; &quot;two_col_ind&quot; &quot;vec&quot; &quot;x&quot; &quot;y&quot; # Remove objects from the environment rm(list = ls()) ## remove all objects in the global environment # For a particular method, list available implementations for different classes methods(summary) #&gt; [1] summary.aov summary.aovlist* #&gt; [3] summary.aspell* summary.check_packages_in_dir* #&gt; [5] summary.connection summary.data.frame #&gt; [7] summary.Date summary.default #&gt; [9] summary.ecdf* summary.factor #&gt; [11] summary.glm summary.infl* #&gt; [13] summary.lm summary.loess* #&gt; [15] summary.manova summary.matrix #&gt; [17] summary.mlm* summary.nls* #&gt; [19] summary.NullVerbose* summary.packageStatus* #&gt; [21] summary.POSIXct summary.POSIXlt #&gt; [23] summary.ppr* summary.prcomp* #&gt; [25] summary.princomp* summary.proc_time #&gt; [27] summary.rlang:::list_of_conditions* summary.rlang_error* #&gt; [29] summary.rlang_message* summary.rlang_trace* #&gt; [31] summary.rlang_warning* summary.srcfile #&gt; [33] summary.srcref summary.stepfun #&gt; [35] summary.stl* summary.table #&gt; [37] summary.tukeysmooth* summary.vctrs_sclr* #&gt; [39] summary.vctrs_vctr* summary.Verbose* #&gt; [41] summary.warnings #&gt; see &#39;?methods&#39; for accessing help and source code # List methods available for a particular class methods(class = &quot;lm&quot;) #&gt; [1] add1 alias anova case.names coerce #&gt; [6] confint cooks.distance deviance dfbeta dfbetas #&gt; [11] drop1 dummy.coef effects extractAIC family #&gt; [16] formula hatvalues influence initialize kappa #&gt; [21] labels logLik model.frame model.matrix nobs #&gt; [26] plot predict print proj qr #&gt; [31] residuals rstandard rstudent show simulate #&gt; [36] slotsFromS3 summary variable.names vcov #&gt; see &#39;?methods&#39; for accessing help and source code # Call a function with arguments as a list (list_of_int &lt;- as.list(1:5)) #&gt; [[1]] #&gt; [1] 1 #&gt; #&gt; [[2]] #&gt; [1] 2 #&gt; #&gt; [[3]] #&gt; [1] 3 #&gt; #&gt; [[4]] #&gt; [1] 4 #&gt; #&gt; [[5]] #&gt; [1] 5 do.call(&#39;c&#39;, list_of_int) #&gt; [1] 1 2 3 4 5 3.4.2 Sequence and vector operations 1:10 ## of type integer #&gt; [1] 1 2 3 4 5 6 7 8 9 10 seq(1, 10, by = 2) ## of type double #&gt; [1] 1 3 5 7 9 seq(1, 100, length.out = 10) #&gt; [1] 1 12 23 34 45 56 67 78 89 100 seq_len(5) #&gt; [1] 1 2 3 4 5 seq_along(21:24) #&gt; [1] 1 2 3 4 rep(1:4, 2) #&gt; [1] 1 2 3 4 1 2 3 4 rep(1:4, each = 2) #&gt; [1] 1 1 2 2 3 3 4 4 rep(1:4, 4:1) #&gt; [1] 1 1 1 1 2 2 2 3 3 4 rep_len(1:3, 8) #&gt; [1] 1 2 3 1 2 3 1 2 replicate(5, rnorm(10)) ## How to use a multiline expression? #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] -1.33067255 0.5411062 0.19105745 -0.8803778 -0.13432133 #&gt; [2,] -0.31081385 1.5144132 -0.01233867 1.0475552 0.83393930 #&gt; [3,] -0.79988841 -1.1042035 -0.72793186 -0.5605354 0.93188377 #&gt; [4,] 0.22874074 -0.9007255 0.77324857 -1.7214477 0.74298540 #&gt; [5,] 0.20547215 0.4852451 -1.66979603 -0.4953465 0.78887440 #&gt; [6,] -0.61010333 -0.7862679 0.31370631 2.2104081 -0.39935950 #&gt; [7,] 0.09342706 -0.3100913 -0.15966018 1.7790441 -1.72538432 #&gt; [8,] -0.59891728 -2.4936207 -0.29846233 -2.1670021 0.07230877 #&gt; [9,] -0.02290819 -0.1928684 0.74592759 2.2903088 -0.31837295 #&gt; [10,] -0.64181396 -0.4647157 1.76659585 0.3401623 -0.64424578 sort(c(1, 6, 8, 2, 2)) #&gt; [1] 1 2 2 6 8 order(c(1, 6, 8, 2, 2), c(0, 0, 0, 2, 1)) #&gt; [1] 1 5 4 2 3 rank(c(1, 6, 8, 2, 2)) #&gt; [1] 1.0 4.0 5.0 2.5 2.5 rank(c(1, 6, 8, 2, 2), ties.method = &quot;first&quot;) #&gt; [1] 1 4 5 2 3 sort(c(&quot;a1&quot;, &quot;a2&quot;, &quot;a10&quot;)) #&gt; [1] &quot;a1&quot; &quot;a10&quot; &quot;a2&quot; gtools::mixedsort(c(&quot;a1&quot;, &quot;a2&quot;, &quot;a10&quot;)) ## not in base, but useful #&gt; [1] &quot;a1&quot; &quot;a2&quot; &quot;a10&quot; which.max(c(1, 5, 3, 6, 2, 0)) #&gt; [1] 4 which.min(c(1, 5, 3, 6, 2, 0)) #&gt; [1] 6 unique(c(1, NA, 2, 3, 2, NA, 3)) #&gt; [1] 1 NA 2 3 table(rep(1:4, 4:1)) #&gt; #&gt; 1 2 3 4 #&gt; 4 3 2 1 table(A = c(1, 1, 1, 2, 2), B = c(1, 2, 1, 2, 1)) #&gt; B #&gt; A 1 2 #&gt; 1 2 1 #&gt; 2 1 1 sample(10) #&gt; [1] 9 2 6 5 4 7 1 10 8 3 sample(3:10, 5) #&gt; [1] 10 7 4 8 9 sample(3:10, 50, replace = TRUE) #&gt; [1] 10 8 5 6 9 8 3 8 9 8 10 6 3 6 5 5 8 7 3 6 8 10 5 7 5 6 9 7 #&gt; [29] 8 7 9 8 8 6 3 6 4 4 7 3 7 7 4 4 9 4 4 8 6 7 round(x &lt;- runif(10, max = 100)) ## 10 random numbers between 0 and 100 #&gt; [1] 69 85 50 62 90 84 90 66 32 23 round(x, digits = 2) #&gt; [1] 69.46 85.04 49.70 61.90 90.19 83.88 89.97 66.08 31.54 22.53 round(x, -1) #&gt; [1] 70 90 50 60 90 80 90 70 30 20 pmin(1:4, 4:1) #&gt; [1] 1 2 2 1 pmax(1:4, 4:1) #&gt; [1] 4 3 3 4 outer(1:4, 1:3, &#39;+&#39;) #&gt; [,1] [,2] [,3] #&gt; [1,] 2 3 4 #&gt; [2,] 3 4 5 #&gt; [3,] 4 5 6 #&gt; [4,] 5 6 7 expand.grid(param1 = c(5, 50), param2 = c(1, 3, 10)) #&gt; param1 param2 #&gt; 1 5 1 #&gt; 2 50 1 #&gt; 3 5 3 #&gt; 4 50 3 #&gt; 5 5 10 #&gt; 6 50 10 Also see this nice Q/A on grouping functions and the *apply family and this book chapter about looping. 3.4.3 Character operations paste(&quot;I&quot;, &quot;am&quot;, &quot;me&quot;) #&gt; [1] &quot;I am me&quot; paste0(&quot;test&quot;, 0) #&gt; [1] &quot;test0&quot; paste0(&quot;PC&quot;, 1:10) #&gt; [1] &quot;PC1&quot; &quot;PC2&quot; &quot;PC3&quot; &quot;PC4&quot; &quot;PC5&quot; &quot;PC6&quot; &quot;PC7&quot; &quot;PC8&quot; &quot;PC9&quot; &quot;PC10&quot; me &lt;- &quot;Florian&quot; glue::glue(&quot;I am {me}&quot;) ## not in base, but so useful #&gt; I am Florian (x &lt;- list.files(pattern = &quot;\\\\.Rmd$&quot;, full.names = TRUE)) #&gt; [1] &quot;./good-practices.Rmd&quot; &quot;./index.Rmd&quot; &quot;./intro.Rmd&quot; #&gt; [4] &quot;./packages.Rmd&quot; &quot;./performance.Rmd&quot; &quot;./presentation_project.Rmd&quot; #&gt; [7] &quot;./r-programming.Rmd&quot; &quot;./shiny.Rmd&quot; &quot;./tidyverse.Rmd&quot; sub(&quot;\\\\.Rmd$&quot;, &quot;.pdf&quot;, x) #&gt; [1] &quot;./good-practices.pdf&quot; &quot;./index.pdf&quot; &quot;./intro.pdf&quot; #&gt; [4] &quot;./packages.pdf&quot; &quot;./performance.pdf&quot; &quot;./presentation_project.pdf&quot; #&gt; [7] &quot;./r-programming.pdf&quot; &quot;./shiny.pdf&quot; &quot;./tidyverse.pdf&quot; (y &lt;- sample(letters[1:4], 10, replace = TRUE)) #&gt; [1] &quot;c&quot; &quot;c&quot; &quot;c&quot; &quot;d&quot; &quot;c&quot; &quot;d&quot; &quot;c&quot; &quot;c&quot; &quot;d&quot; &quot;a&quot; match(y, letters[1:4]) #&gt; [1] 3 3 3 4 3 4 3 3 4 1 y %in% letters[1:2] #&gt; [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE split(1:12, rep(letters[1:3], 4)) #&gt; $a #&gt; [1] 1 4 7 10 #&gt; #&gt; $b #&gt; [1] 2 5 8 11 #&gt; #&gt; $c #&gt; [1] 3 6 9 12 intersect(letters[1:4], letters[3:5]) #&gt; [1] &quot;c&quot; &quot;d&quot; union(letters[1:4], letters[3:5]) #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; setdiff(letters[1:4], letters[3:5]) #&gt; [1] &quot;a&quot; &quot;b&quot; 3.4.4 Logical operators TRUE | stop(&quot;will go there&quot;) #&gt; Error in eval(expr, envir, enclos): will go there TRUE || stop(&quot;won&#39;t go there&quot;) ## won&#39;t evaluate second condition if first one is TRUE #&gt; [1] TRUE c(TRUE, FALSE, TRUE, TRUE) &amp; c(FALSE, TRUE, TRUE, FALSE) #&gt; [1] FALSE FALSE TRUE FALSE c(TRUE, FALSE, TRUE, TRUE) &amp;&amp; c(FALSE, TRUE, TRUE, FALSE) ## /!\\ no warning in prior R versions #&gt; Error in c(TRUE, FALSE, TRUE, TRUE) &amp;&amp; c(FALSE, TRUE, TRUE, FALSE): &#39;length = 4&#39; in coercion to &#39;logical(1)&#39; (x &lt;- rnorm(10)) #&gt; [1] -0.67190548 0.87590357 -0.54885431 0.08878470 0.49701558 0.15690067 -0.06717901 #&gt; [8] -0.03702561 -0.39669019 0.66214360 ifelse(x &gt; 0, x, -x) # try to find two other equivalents #&gt; [1] 0.67190548 0.87590357 0.54885431 0.08878470 0.49701558 0.15690067 0.06717901 #&gt; [8] 0.03702561 0.39669019 0.66214360 Beware with ifelse() (learn more there), for example ifelse(FALSE, 0, 1:5) #&gt; [1] 1 `if`(FALSE, 0, 1:5) #&gt; [1] 1 2 3 4 5 if (FALSE) 0 else 1:5 #&gt; [1] 1 2 3 4 5 3.4.5 Exercises Use sample(), rep_len() and split() to make a function that randomly splits some indices in a list of K groups of indices (like for cross-validation). [Which are the special cases that you should consider?] advr38pkg::split_ind(1:40, 3) #&gt; $`1` #&gt; [1] 4 7 11 12 14 15 16 18 23 29 31 32 33 39 #&gt; #&gt; $`2` #&gt; [1] 1 2 3 6 8 13 20 24 25 28 36 37 38 #&gt; #&gt; $`3` #&gt; [1] 5 9 10 17 19 21 22 26 27 30 34 35 40 Use replicate() and sample() to get a 95% confidence interval (using bootstrapping) for the mean of the following vector: set.seed(1) (x &lt;- rnorm(10)) #&gt; [1] -0.6264538 0.1836433 -0.8356286 1.5952808 0.3295078 -0.8204684 0.4874291 #&gt; [8] 0.7383247 0.5757814 -0.3053884 mean(x) #&gt; [1] 0.1322028 Expected output (approximately): #&gt; 2.5% 97.5% #&gt; -0.3145143 0.5998608 Use match() and some special accessor to add a column “my_val” to this data my_mtcars by putting the corresponding value of the column specified in “my_col”. [Can your solution be used for any number of column names?] my_mtcars &lt;- mtcars[c(&quot;mpg&quot;, &quot;hp&quot;)] my_mtcars$my_col &lt;- sample(c(&quot;mpg&quot;, &quot;hp&quot;), size = nrow(my_mtcars), replace = TRUE) head(my_mtcars) #&gt; mpg hp my_col #&gt; Mazda RX4 21.0 110 mpg #&gt; Mazda RX4 Wag 21.0 110 mpg #&gt; Datsun 710 22.8 93 hp #&gt; Hornet 4 Drive 21.4 110 hp #&gt; Hornet Sportabout 18.7 175 mpg #&gt; Valiant 18.1 105 hp Expected result (head): #&gt; mpg hp my_col my_val #&gt; Mazda RX4 21.0 110 mpg 21.0 #&gt; Mazda RX4 Wag 21.0 110 mpg 21.0 #&gt; Datsun 710 22.8 93 hp 93 #&gt; Hornet 4 Drive 21.4 110 hp 110 #&gt; Hornet Sportabout 18.7 175 mpg 18.7 #&gt; Valiant 18.1 105 hp 105 In the following data frame (recall that a data frame is also a list), for the first 3 columns, replace letters by corresponding numbers based on the code: df &lt;- data.frame( id1 = c(&quot;a&quot;, &quot;f&quot;, &quot;a&quot;), id2 = c(&quot;b&quot;, &quot;e&quot;, &quot;e&quot;), id3 = c(&quot;c&quot;, &quot;d&quot;, &quot;f&quot;), inter = c(7.343, 2.454, 3.234), stringsAsFactors = FALSE ) df #&gt; id1 id2 id3 inter #&gt; 1 a b c 7.343 #&gt; 2 f e d 2.454 #&gt; 3 a e f 3.234 (code &lt;- setNames(1:6, letters[1:6])) #&gt; a b c d e f #&gt; 1 2 3 4 5 6 Expected result: #&gt; id1 id2 id3 inter #&gt; 1 1 2 3 7.343 #&gt; 2 6 5 4 2.454 #&gt; 3 1 5 6 3.234 3.5 Environments and scoping Lexical scoping determines where to look for values, not when to look for them. R looks for values when the function is run, not when it’s created. This means that the output of a function can be different depending on objects outside its environment: h &lt;- function() { x &lt;- 10 f &lt;- function() { x + 1 } f() } x &lt;- 100 h() #&gt; [1] 11 Variable x is not defined inside f so R will look at the environment of f (where f was defined) and then at the parent environment, and so on. Here, the first x that is found has value 10. Be aware that for functions, packages environments are checked last so that you can redefine functions without noticing. c &lt;- function(...) paste0(...) c(1, 2, 3) #&gt; [1] &quot;123&quot; base::c(1, 2, 3) ## you need to explicit the package #&gt; [1] 1 2 3 rm(c) ## remove the new function from the environment c(1, 2, 3) #&gt; [1] 1 2 3 You can use the &lt;&lt;- operator to change the value of an object in an upper environment: count1 &lt;- 0 count2 &lt;- 0 f &lt;- function(i) { count1 &lt;- count1 + 1 ## will assign a new (temporary) count1 each time count2 &lt;&lt;- count2 + 1 ## will increment count2 on top i + 1 } sapply(1:10, f) #&gt; [1] 2 3 4 5 6 7 8 9 10 11 c(count1, count2) #&gt; [1] 0 10 Finally, how does ... work? Basically, you copy and paste what is put in ...: f1 &lt;- function(...) { list(...) } f1(a = 2, b = 3) #&gt; $a #&gt; [1] 2 #&gt; #&gt; $b #&gt; [1] 3 list(a = 2, b = 3) #&gt; $a #&gt; [1] 2 #&gt; #&gt; $b #&gt; [1] 3 Learn more about functions and scoping rules of R with the R Programming for Data Science book. 3.6 Attributes and classes Attributes are metadata associated with an object. You can get/set the list of attributes with attributes() or one particular attribute with attr(). attributes(iris) #&gt; $names #&gt; [1] &quot;Sepal.Length&quot; &quot;Sepal.Width&quot; &quot;Petal.Length&quot; &quot;Petal.Width&quot; &quot;Species&quot; #&gt; #&gt; $class #&gt; [1] &quot;data.frame&quot; #&gt; #&gt; $row.names #&gt; [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #&gt; [22] 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #&gt; [43] 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #&gt; [64] 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 #&gt; [85] 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 #&gt; [106] 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 #&gt; [127] 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 #&gt; [148] 148 149 150 class(iris) #&gt; [1] &quot;data.frame&quot; attr(iris, &quot;row.names&quot;) #&gt; [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #&gt; [22] 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #&gt; [43] 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #&gt; [64] 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 #&gt; [85] 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 #&gt; [106] 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 #&gt; [127] 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 #&gt; [148] 148 149 150 You can use structure() to create an object and add some arbitrary attributes. structure(1:10, my_fancy_attribute = &quot;blabla&quot;) #&gt; [1] 1 2 3 4 5 6 7 8 9 10 #&gt; attr(,&quot;my_fancy_attribute&quot;) #&gt; [1] &quot;blabla&quot; There are also some attributes with specific accessor functions to get and set values. For example, use names(x), dim(x) and class(x) instead of attr(x, \"names\"), attr(x, \"dim\") and attr(x, \"class\"). class(mylm &lt;- lm(Sepal.Length ~ ., data = iris)) #&gt; [1] &quot;lm&quot; I’ve just fitted a linear model in order to predict the sepal length variable of the iris dataset based on the other variables. Using lm() gets me an object of class lm. What are the methods I can use for this object? methods(class = class(mylm)) #&gt; [1] add1 alias anova case.names coerce #&gt; [6] confint cooks.distance deviance dfbeta dfbetas #&gt; [11] drop1 dummy.coef effects extractAIC family #&gt; [16] formula hatvalues influence initialize kappa #&gt; [21] labels logLik model.frame model.matrix nobs #&gt; [26] plot predict print proj qr #&gt; [31] residuals rstandard rstudent show simulate #&gt; [36] slotsFromS3 summary variable.names vcov #&gt; see &#39;?methods&#39; for accessing help and source code summary(mylm) #&gt; #&gt; Call: #&gt; lm(formula = Sepal.Length ~ ., data = iris) #&gt; #&gt; Residuals: #&gt; Min 1Q Median 3Q Max #&gt; -0.79424 -0.21874 0.00899 0.20255 0.73103 #&gt; #&gt; Coefficients: #&gt; Estimate Std. Error t value Pr(&gt;|t|) #&gt; (Intercept) 2.17127 0.27979 7.760 1.43e-12 *** #&gt; Sepal.Width 0.49589 0.08607 5.761 4.87e-08 *** #&gt; Petal.Length 0.82924 0.06853 12.101 &lt; 2e-16 *** #&gt; Petal.Width -0.31516 0.15120 -2.084 0.03889 * #&gt; Speciesversicolor -0.72356 0.24017 -3.013 0.00306 ** #&gt; Speciesvirginica -1.02350 0.33373 -3.067 0.00258 ** #&gt; --- #&gt; Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 #&gt; #&gt; Residual standard error: 0.3068 on 144 degrees of freedom #&gt; Multiple R-squared: 0.8673, Adjusted R-squared: 0.8627 #&gt; F-statistic: 188.3 on 5 and 144 DF, p-value: &lt; 2.2e-16 plot(mylm) R has the easiest way to create a class and to use methods on objects of this class; it is called S3. If you want to know more about the other types of classes, see the Advanced R book. agent007 &lt;- list(first = &quot;James&quot;, last = &quot;Bond&quot;) agent007 #&gt; $first #&gt; [1] &quot;James&quot; #&gt; #&gt; $last #&gt; [1] &quot;Bond&quot; class(agent007) &lt;- &quot;Person&quot; ## &quot;agent007&quot; is now an object of class &quot;Person&quot; # Just make a function called &lt;method_name&gt;.&lt;class_name&gt;() print.Person &lt;- function(x) { print(glue::glue(&quot;My name is {x$last}, {x$first} {x$last}.&quot;)) invisible(x) } agent007 #&gt; My name is Bond, James Bond. # Constructor of class as simple function Person &lt;- function(first, last) { structure(list(first = first, last = last), class = &quot;Person&quot;) } (me &lt;- Person(&quot;Florian&quot;, &quot;Privé&quot;)) #&gt; My name is Privé, Florian Privé. An object can have many classes: Worker &lt;- function(first, last, job) { obj &lt;- Person(first, last) obj$job &lt;- job class(obj) &lt;- c(&quot;Worker&quot;, class(obj)) obj } print.Worker &lt;- function(x) { print.Person(x) print(glue::glue(&quot;I am a {x$job}.&quot;)) invisible(x) } (worker_007 &lt;- Worker(&quot;James&quot;, &quot;Bond&quot;, &quot;secret agent&quot;)) #&gt; My name is Bond, James Bond. #&gt; I am a secret agent. (worker_me &lt;- Worker(&quot;Florian&quot;, &quot;Privé&quot;, &quot;researcher&quot;)) #&gt; My name is Privé, Florian Privé. #&gt; I am a researcher. Learn more with the Advanced R book. 3.7 Summary Useful resources Computer Floating-Point Arithmetic and round-off errors, article by Kausal Kaluarachchi. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
