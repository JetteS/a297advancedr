[
["r-programming.html", "Chapter 3 R programming 3.1 Common mistakes 3.2 R base objects 3.3 Base objects and accessors 3.4 Useful R base functions 3.5 Environments and scoping 3.6 Attributes and classes", " Chapter 3 R programming This chapter is about base R stuff that I find important and that are often overlooked or unknown to most R users. Learn more with the Advanced R book. 3.1 Common mistakes If you are using R and you think you’re in hell, this is a map for you. – Patrick Burns 3.1.1 Equality (0.1 + 0.2) == 0.3 #&gt; [1] FALSE print(c(0.1, 0.2, 0.3), digits = 20) #&gt; [1] 0.10000000000000000555 0.20000000000000001110 0.29999999999999998890 all.equal(0.1 + 0.2, 0.3) ## equality with some tolerance #&gt; [1] TRUE isTRUE(all.equal(0.1 + 0.2, 0.4)) ## if you want a boolean, use isTRUE() #&gt; [1] FALSE 3.1.2 Arguments min(-1, 5, 118) #&gt; [1] -1 max(-1, 5, 118) #&gt; [1] 118 args(max) #&gt; function (..., na.rm = FALSE) #&gt; NULL mean(-1, 5, 118) #&gt; [1] -1 args(mean) #&gt; function (x, ...) #&gt; NULL median(-1, 5, 118) #&gt; [1] -1 args(median) #&gt; function (x, na.rm = FALSE, ...) #&gt; NULL Always use one vector if you’re not sure: min(c(-1, 5, 118)) #&gt; [1] -1 max(c(-1, 5, 118)) #&gt; [1] 118 mean(c(-1, 5, 118)) #&gt; [1] 40.66667 median(c(-1, 5, 118)) #&gt; [1] 5 3.1.3 Others sample(1:10) #&gt; [1] 8 7 10 4 5 3 9 1 6 2 sample(10) #&gt; [1] 3 10 6 2 8 4 9 7 1 5 sample(10.1) #&gt; [1] 4 9 5 8 6 10 3 1 2 7 1:0 #&gt; [1] 1 0 seq_len(0) ## prefer using seq_len (e.g. in for-loops) #&gt; integer(0) n &lt;- 10 1:n+1 # is (1:n) + 1, so 2:(n + 1) #&gt; [1] 2 3 4 5 6 7 8 9 10 11 1:(n+1) #&gt; [1] 1 2 3 4 5 6 7 8 9 10 11 seq_len(n + 1) #&gt; [1] 1 2 3 4 5 6 7 8 9 10 11 3.2 R base objects 3.2.1 Types There are many “atomic” types of data: logical, integer, double and character (in this order, see below). There are also raw and complex but they are rarely used. You can’t mix types in an atomic vector (you can in a list). Coercion will automatically occur if you mix types: (a &lt;- FALSE) #&gt; [1] FALSE typeof(a) #&gt; [1] &quot;logical&quot; (b &lt;- 1:10) #&gt; [1] 1 2 3 4 5 6 7 8 9 10 typeof(b) #&gt; [1] &quot;integer&quot; c(a, b) ## FALSE is coerced to integer 0 #&gt; [1] 0 1 2 3 4 5 6 7 8 9 10 (c &lt;- 10.5) #&gt; [1] 10.5 typeof(c) #&gt; [1] &quot;double&quot; (d &lt;- c(b, c)) ## coerced to numeric #&gt; [1] 1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0 10.0 10.5 c(d, &quot;a&quot;) ## coerced to character #&gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; &quot;10.5&quot; &quot;a&quot; c(list(1), &quot;a&quot;) #&gt; [[1]] #&gt; [1] 1 #&gt; #&gt; [[2]] #&gt; [1] &quot;a&quot; 50 &lt; &quot;7&quot; ## &quot;50&quot; &lt; &quot;7&quot; #&gt; [1] TRUE 3.2.2 Exercise Use the automatic type coercion to convert this boolean matrix to a numeric one (with 0s and 1s). [What do you need to change to get an integer matrix instead?] (mat &lt;- matrix(sample(c(TRUE, FALSE), 12, replace = TRUE), 3)) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] TRUE FALSE FALSE FALSE #&gt; [2,] FALSE TRUE FALSE FALSE #&gt; [3,] TRUE FALSE TRUE FALSE 3.3 Base objects and accessors 3.3.1 Objects “atomic” vector: vector of one base type (see above). scalar: this doesn’t exist, this is a vector of length 1. matrices / arrays: a vector with some dimensions (attribute). (vec &lt;- 1:12) #&gt; [1] 1 2 3 4 5 6 7 8 9 10 11 12 dim(vec) &lt;- c(3, 4) vec #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 class(vec) #&gt; [1] &quot;matrix&quot; dim(vec) &lt;- c(3, 2, 2) vec #&gt; , , 1 #&gt; #&gt; [,1] [,2] #&gt; [1,] 1 4 #&gt; [2,] 2 5 #&gt; [3,] 3 6 #&gt; #&gt; , , 2 #&gt; #&gt; [,1] [,2] #&gt; [1,] 7 10 #&gt; [2,] 8 11 #&gt; [3,] 9 12 class(vec) #&gt; [1] &quot;array&quot; list: vector of elements with possibly different types in it. data.frame: a list whose elements have the same lengths, and formatted somewhat as a matrix. 3.3.2 Accessors The [ accessor is used to access a subset of the data with the same class. (x &lt;- runif(5)) #&gt; [1] 0.18139077 0.55953454 0.05252807 0.40885059 0.26776703 x[2:3] #&gt; [1] 0.55953454 0.05252807 x[2:8] #&gt; [1] 0.55953454 0.05252807 0.40885059 0.26776703 NA NA NA (y &lt;- matrix(runif(12), 3)) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 0.4255987 0.7326619 0.3891007 0.1585801 #&gt; [2,] 0.2063418 0.6494367 0.5302394 0.3973534 #&gt; [3,] 0.9428522 0.8671873 0.9433167 0.6578638 y[4:9] ## a matrix is a vector #&gt; [1] 0.7326619 0.6494367 0.8671873 0.3891007 0.5302394 0.9433167 (l &lt;- list(a = 2:3, b = &quot;toto&quot;, c = runif(10))) #&gt; $a #&gt; [1] 2 3 #&gt; #&gt; $b #&gt; [1] &quot;toto&quot; #&gt; #&gt; $c #&gt; [1] 0.9876296 0.2063950 0.2900185 0.1563577 0.3303297 0.2982070 0.0874376 0.5990777 #&gt; [9] 0.4304789 0.3054265 l[2:3] #&gt; $b #&gt; [1] &quot;toto&quot; #&gt; #&gt; $c #&gt; [1] 0.9876296 0.2063950 0.2900185 0.1563577 0.3303297 0.2982070 0.0874376 0.5990777 #&gt; [9] 0.4304789 0.3054265 head(iris) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 1 5.1 3.5 1.4 0.2 setosa #&gt; 2 4.9 3.0 1.4 0.2 setosa #&gt; 3 4.7 3.2 1.3 0.2 setosa #&gt; 4 4.6 3.1 1.5 0.2 setosa #&gt; 5 5.0 3.6 1.4 0.2 setosa #&gt; 6 5.4 3.9 1.7 0.4 setosa head(iris[3:4]) #&gt; Petal.Length Petal.Width #&gt; 1 1.4 0.2 #&gt; 2 1.4 0.2 #&gt; 3 1.3 0.2 #&gt; 4 1.5 0.2 #&gt; 5 1.4 0.2 #&gt; 6 1.7 0.4 class(iris[5]) #&gt; [1] &quot;data.frame&quot; You can also use a logical and character vectors to index these objects. (x &lt;- runif(4)) #&gt; [1] 0.843589424 0.051424374 0.008759948 0.853040871 x[c(FALSE, TRUE, FALSE, TRUE)] #&gt; [1] 0.05142437 0.85304087 x[c(FALSE, TRUE)] ## logical vectors are recycled #&gt; [1] 0.05142437 0.85304087 head(iris[c(&quot;Petal.Length&quot;, &quot;Species&quot;)]) #&gt; Petal.Length Species #&gt; 1 1.4 setosa #&gt; 2 1.4 setosa #&gt; 3 1.3 setosa #&gt; 4 1.5 setosa #&gt; 5 1.4 setosa #&gt; 6 1.7 setosa The [[ accessor is used to access a single element. (x &lt;- 1:10) #&gt; [1] 1 2 3 4 5 6 7 8 9 10 x[[3]] #&gt; [1] 3 l[[2]] #&gt; [1] &quot;toto&quot; iris[[&quot;Species&quot;]] #&gt; [1] setosa setosa setosa setosa setosa setosa setosa #&gt; [8] setosa setosa setosa setosa setosa setosa setosa #&gt; [15] setosa setosa setosa setosa setosa setosa setosa #&gt; [22] setosa setosa setosa setosa setosa setosa setosa #&gt; [29] setosa setosa setosa setosa setosa setosa setosa #&gt; [36] setosa setosa setosa setosa setosa setosa setosa #&gt; [43] setosa setosa setosa setosa setosa setosa setosa #&gt; [50] setosa versicolor versicolor versicolor versicolor versicolor versicolor #&gt; [57] versicolor versicolor versicolor versicolor versicolor versicolor versicolor #&gt; [64] versicolor versicolor versicolor versicolor versicolor versicolor versicolor #&gt; [71] versicolor versicolor versicolor versicolor versicolor versicolor versicolor #&gt; [78] versicolor versicolor versicolor versicolor versicolor versicolor versicolor #&gt; [85] versicolor versicolor versicolor versicolor versicolor versicolor versicolor #&gt; [92] versicolor versicolor versicolor versicolor versicolor versicolor versicolor #&gt; [99] versicolor versicolor virginica virginica virginica virginica virginica #&gt; [106] virginica virginica virginica virginica virginica virginica virginica #&gt; [113] virginica virginica virginica virginica virginica virginica virginica #&gt; [120] virginica virginica virginica virginica virginica virginica virginica #&gt; [127] virginica virginica virginica virginica virginica virginica virginica #&gt; [134] virginica virginica virginica virginica virginica virginica virginica #&gt; [141] virginica virginica virginica virginica virginica virginica virginica #&gt; [148] virginica virginica virginica #&gt; Levels: setosa versicolor virginica Figure 3.1: Indexing lists in R. [Source: https://goo.gl/8UkcHq] Beware partial matching x &lt;- list(aardvark = 1:5) x$a #&gt; [1] 1 2 3 4 5 x[[&quot;a&quot;]] #&gt; NULL x[[&quot;a&quot;, exact = FALSE]] #&gt; [1] 1 2 3 4 5 Special use of the [ accessor for array-like data. (mat &lt;- matrix(1:12, 3)) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 mat[1, ] #&gt; [1] 1 4 7 10 mat[, 1:2] #&gt; [,1] [,2] #&gt; [1,] 1 4 #&gt; [2,] 2 5 #&gt; [3,] 3 6 mat[1, 1:2] #&gt; [1] 1 4 mat[1, 1:2, drop = FALSE] #&gt; [,1] [,2] #&gt; [1,] 1 4 mat[cbind(1, 1:2)] #&gt; [1] 1 4 mat[,] #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 mat[] #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 mat[] &lt;- 2 mat #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 2 2 2 2 #&gt; [2,] 2 2 2 2 #&gt; [3,] 2 2 2 2 Just add a comma for every new dimension. 3.3.3 Exercises Use the dimension attribute to make a function that computes the sums every n elements of a vector. In which order are matrix elements stored? [Which are the special cases that you should consider?] advr38pkg::sum_every(1:10, 2) #&gt; [1] 3 7 11 15 19 Compute the means of every numeric columns of the iris dataset. Expected result: #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width #&gt; 5.843333 3.057333 3.758000 1.199333 Convert this matrix to a vector by replacing c(1,0,0) -&gt; 0; c(0,1,0) -&gt; 1; c(0,0,1) -&gt; 2; other -&gt; NA mat &lt;- matrix(0, 10, 3); mat[c(1, 5, 8, 12, 16, 17, 19, 23, 24, 29)] &lt;- 1; mat #&gt; [,1] [,2] [,3] #&gt; [1,] 1 0 0 #&gt; [2,] 0 1 0 #&gt; [3,] 0 0 1 #&gt; [4,] 0 0 1 #&gt; [5,] 1 0 0 #&gt; [6,] 0 1 0 #&gt; [7,] 0 1 0 #&gt; [8,] 1 0 0 #&gt; [9,] 0 1 1 #&gt; [10,] 0 0 0 by using this array: myarray &lt;- array(dim = c(2, 2, 2)) myarray[2, 1, 1] &lt;- 0 myarray[1, 2, 1] &lt;- 1 myarray[1, 1, 2] &lt;- 2 myarray #&gt; , , 1 #&gt; #&gt; [,1] [,2] #&gt; [1,] NA 1 #&gt; [2,] 0 NA #&gt; #&gt; , , 2 #&gt; #&gt; [,1] [,2] #&gt; [1,] 2 NA #&gt; [2,] NA NA Begin by using apply() and then replace it by a special accessor; what is the advantage? Expected result: #&gt; [1] 0 1 2 2 0 1 1 0 NA NA 3.4 Useful R base functions In this section, I mention some useful R base functions (also see this comprehensive list in French and this one in English): 3.4.1 General # To get some help ?topic #&gt; No documentation for &#39;topic&#39; in specified packages and libraries: #&gt; you could try &#39;??topic&#39; # Run code from the example section example(sum) #&gt; #&gt; sum&gt; ## Pass a vector to sum, and it will add the elements together. #&gt; sum&gt; sum(1:5) #&gt; [1] 15 #&gt; #&gt; sum&gt; ## Pass several numbers to sum, and it also adds the elements. #&gt; sum&gt; sum(1, 2, 3, 4, 5) #&gt; [1] 15 #&gt; #&gt; sum&gt; ## In fact, you can pass vectors into several arguments, and everything gets added. #&gt; sum&gt; sum(1:2, 3:5) #&gt; [1] 15 #&gt; #&gt; sum&gt; ## If there are missing values, the sum is unknown, i.e., also missing, .... #&gt; sum&gt; sum(1:5, NA) #&gt; [1] NA #&gt; #&gt; sum&gt; ## ... unless we exclude missing values explicitly: #&gt; sum&gt; sum(1:5, NA, na.rm = TRUE) #&gt; [1] 15 # Structure overview str(iris) #&gt; &#39;data.frame&#39;: 150 obs. of 5 variables: #&gt; $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... #&gt; $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... #&gt; $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... #&gt; $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... #&gt; $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... # List objects of environment a &lt;- 1:4; b &lt;- list() ls() #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; #&gt; [5] &quot;decode&quot; &quot;l&quot; &quot;mat&quot; &quot;myarray&quot; #&gt; [9] &quot;n&quot; &quot;vec&quot; &quot;WORDS_TO_IGNORE&quot; &quot;x&quot; #&gt; [13] &quot;y&quot; # Remove objects from the environment rm(list = ls()) ## remove all objects in the environment # list of available S3 methods methods(summary) #&gt; [1] summary.aov summary.aovlist* #&gt; [3] summary.aspell* summary.check_packages_in_dir* #&gt; [5] summary.connection summary.data.frame #&gt; [7] summary.Date summary.default #&gt; [9] summary.ecdf* summary.factor #&gt; [11] summary.glm summary.infl* #&gt; [13] summary.lm summary.loess* #&gt; [15] summary.manova summary.matrix #&gt; [17] summary.mlm* summary.nls* #&gt; [19] summary.packageStatus* summary.PDF_Dictionary* #&gt; [21] summary.PDF_Stream* summary.POSIXct #&gt; [23] summary.POSIXlt summary.ppr* #&gt; [25] summary.prcomp* summary.princomp* #&gt; [27] summary.proc_time summary.srcfile #&gt; [29] summary.srcref summary.stepfun #&gt; [31] summary.stl* summary.table #&gt; [33] summary.tukeysmooth* #&gt; see &#39;?methods&#39; for accessing help and source code methods(class = &quot;lm&quot;) #&gt; [1] add1 alias anova case.names coerce #&gt; [6] confint cooks.distance deviance dfbeta dfbetas #&gt; [11] drop1 dummy.coef effects extractAIC family #&gt; [16] formula hatvalues influence initialize kappa #&gt; [21] labels logLik model.frame model.matrix nobs #&gt; [26] plot predict print proj qr #&gt; [31] residuals rstandard rstudent show simulate #&gt; [36] slotsFromS3 summary variable.names vcov #&gt; see &#39;?methods&#39; for accessing help and source code # Call a function with arguments as a list (list_of_int &lt;- lapply(1:5, function(i) i)) #&gt; [[1]] #&gt; [1] 1 #&gt; #&gt; [[2]] #&gt; [1] 2 #&gt; #&gt; [[3]] #&gt; [1] 3 #&gt; #&gt; [[4]] #&gt; [1] 4 #&gt; #&gt; [[5]] #&gt; [1] 5 do.call(&#39;c&#39;, list_of_int) #&gt; [1] 1 2 3 4 5 3.4.2 Sequence and vector operations 1:10 ## of type integer #&gt; [1] 1 2 3 4 5 6 7 8 9 10 seq(1, 10, by = 2) ## of type double #&gt; [1] 1 3 5 7 9 seq(1, 100, length.out = 10) #&gt; [1] 1 12 23 34 45 56 67 78 89 100 seq_len(5) #&gt; [1] 1 2 3 4 5 seq_along(21:24) #&gt; [1] 1 2 3 4 rep(1:4, 2) #&gt; [1] 1 2 3 4 1 2 3 4 rep(1:4, each = 2) #&gt; [1] 1 1 2 2 3 3 4 4 rep(1:4, 4:1) #&gt; [1] 1 1 1 1 2 2 2 3 3 4 rep_len(1:3, 8) #&gt; [1] 1 2 3 1 2 3 1 2 replicate(5, rnorm(10)) ## How to use a multiline expression? #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] -0.41382373 -0.6647508 -1.0791183 0.215991919 0.07315309 #&gt; [2,] 0.27402753 -1.2194686 0.6621875 1.511963667 -0.84765058 #&gt; [3,] 0.17815564 0.6548748 -1.6169942 1.683119986 1.40312193 #&gt; [4,] 0.76451152 -1.1388267 -0.1586852 -1.038351363 2.02642385 #&gt; [5,] 0.23314661 -0.2334367 1.3629246 1.007666356 -0.33608148 #&gt; [6,] 0.61229245 1.1951100 0.2129690 0.395439610 2.52353447 #&gt; [7,] 0.01548255 0.5674116 -0.5609900 -0.375047830 -1.45026165 #&gt; [8,] 1.80577925 -0.4376031 0.5850716 0.908075359 0.28377674 #&gt; [9,] -1.05821463 -0.7644184 0.7436221 -1.886353278 -1.62697645 #&gt; [10,] -1.05460273 -0.3866324 -2.6243725 0.009662463 0.51847841 sort(c(1, 6, 8, 2, 2)) #&gt; [1] 1 2 2 6 8 order(c(1, 6, 8, 2, 2), c(0, 0, 0, 2, 1)) #&gt; [1] 1 5 4 2 3 rank(c(1, 6, 8, 2, 2)) #&gt; [1] 1.0 4.0 5.0 2.5 2.5 rank(c(1, 6, 8, 2, 2), ties.method = &quot;first&quot;) #&gt; [1] 1 4 5 2 3 sort(c(&quot;a1&quot;, &quot;a2&quot;, &quot;a10&quot;)) #&gt; [1] &quot;a1&quot; &quot;a10&quot; &quot;a2&quot; gtools::mixedsort(c(&quot;a1&quot;, &quot;a2&quot;, &quot;a10&quot;)) ## not in base, obviously #&gt; [1] &quot;a1&quot; &quot;a2&quot; &quot;a10&quot; which.max(c(1, 5, 3, 6, 2, 0)) #&gt; [1] 4 which.min(c(1, 5, 3, 6, 2, 0)) #&gt; [1] 6 unique(c(1, NA, 2, 3, 2, NA, 3)) #&gt; [1] 1 NA 2 3 table(rep(1:4, 4:1)) #&gt; #&gt; 1 2 3 4 #&gt; 4 3 2 1 table(A = c(1, 1, 1, 2, 2), B = c(1, 2, 1, 2, 1)) #&gt; B #&gt; A 1 2 #&gt; 1 2 1 #&gt; 2 1 1 sample(10) #&gt; [1] 9 10 8 6 5 4 2 1 7 3 sample(3:10, 5) #&gt; [1] 3 10 5 6 8 sample(3:10, 50, replace = TRUE) #&gt; [1] 9 4 6 6 7 6 5 7 6 4 4 3 8 5 7 8 5 10 10 4 3 3 3 7 4 4 6 7 #&gt; [29] 7 4 6 8 4 7 8 3 9 10 9 3 7 9 5 3 5 7 5 3 6 3 round(x &lt;- runif(10, max = 100)) #&gt; [1] 7 99 9 80 84 93 56 95 93 23 round(x, digits = 2) #&gt; [1] 6.95 99.06 9.17 80.00 83.50 92.94 55.77 95.09 93.17 22.63 round(x, -1) #&gt; [1] 10 100 10 80 80 90 60 100 90 20 pmin(1:4, 4:1) #&gt; [1] 1 2 2 1 pmax(1:4, 4:1) #&gt; [1] 4 3 3 4 outer(1:4, 1:3, &#39;+&#39;) #&gt; [,1] [,2] [,3] #&gt; [1,] 2 3 4 #&gt; [2,] 3 4 5 #&gt; [3,] 4 5 6 #&gt; [4,] 5 6 7 expand.grid(param1 = c(5, 50), param2 = c(1, 3, 10)) #&gt; param1 param2 #&gt; 1 5 1 #&gt; 2 50 1 #&gt; 3 5 3 #&gt; 4 50 3 #&gt; 5 5 10 #&gt; 6 50 10 Also see this nice Q/A on grouping functions and the *apply family and this book chapter about looping. 3.4.3 Character operations paste(&quot;I&quot;, &quot;am&quot;, &quot;me&quot;) #&gt; [1] &quot;I am me&quot; paste0(&quot;test&quot;, 0) #&gt; [1] &quot;test0&quot; paste0(&quot;PC&quot;, 1:10) #&gt; [1] &quot;PC1&quot; &quot;PC2&quot; &quot;PC3&quot; &quot;PC4&quot; &quot;PC5&quot; &quot;PC6&quot; &quot;PC7&quot; &quot;PC8&quot; &quot;PC9&quot; &quot;PC10&quot; me &lt;- &quot;Florian&quot; glue::glue(&quot;I am {me}&quot;) ## not in base, but SO useful #&gt; I am Florian (x &lt;- list.files(pattern = &quot;\\\\.Rmd$&quot;, full.names = TRUE)) #&gt; [1] &quot;./good-practices.Rmd&quot; &quot;./index.Rmd&quot; &quot;./intro.Rmd&quot; #&gt; [4] &quot;./packages.Rmd&quot; &quot;./performance.Rmd&quot; &quot;./rprog.Rmd&quot; #&gt; [7] &quot;./shiny.Rmd&quot; &quot;./tidyverse.Rmd&quot; sub(&quot;\\\\.Rmd$&quot;, &quot;.pdf&quot;, x) #&gt; [1] &quot;./good-practices.pdf&quot; &quot;./index.pdf&quot; &quot;./intro.pdf&quot; #&gt; [4] &quot;./packages.pdf&quot; &quot;./performance.pdf&quot; &quot;./rprog.pdf&quot; #&gt; [7] &quot;./shiny.pdf&quot; &quot;./tidyverse.pdf&quot; (y &lt;- sample(letters[1:4], 10, replace = TRUE)) #&gt; [1] &quot;b&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;b&quot; &quot;d&quot; &quot;a&quot; match(y, letters[1:4]) #&gt; [1] 2 1 2 3 2 3 4 2 4 1 y %in% letters[1:2] #&gt; [1] TRUE TRUE TRUE FALSE TRUE FALSE FALSE TRUE FALSE TRUE rle(rep(1:4, 4:1)) #&gt; Run Length Encoding #&gt; lengths: int [1:4] 4 3 2 1 #&gt; values : int [1:4] 1 2 3 4 split(1:12, rep(letters[1:3], 4)) #&gt; $a #&gt; [1] 1 4 7 10 #&gt; #&gt; $b #&gt; [1] 2 5 8 11 #&gt; #&gt; $c #&gt; [1] 3 6 9 12 intersect(letters[1:4], letters[3:5]) #&gt; [1] &quot;c&quot; &quot;d&quot; union(letters[1:4], letters[3:5]) #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; setdiff(letters[1:4], letters[3:5]) #&gt; [1] &quot;a&quot; &quot;b&quot; 3.4.4 Logical operators tryCatch(TRUE | stop(&quot;will go there&quot;), error = function(e) print(e)) #&gt; &lt;simpleError in doTryCatch(return(expr), name, parentenv, handler): will go there&gt; TRUE || stop(&quot;won&#39;t go there&quot;) ## won&#39;t evaluate second condition if first one is TRUE #&gt; [1] TRUE c(TRUE, FALSE, TRUE, TRUE) &amp; c(FALSE, TRUE, TRUE, TRUE) #&gt; [1] FALSE FALSE TRUE TRUE c(TRUE, FALSE, TRUE, TRUE) &amp;&amp; c(FALSE, TRUE, TRUE, TRUE) ## no warning!! #&gt; [1] FALSE (x &lt;- rnorm(10)) #&gt; [1] 1.245047959 0.990818114 -1.115016423 -0.275096014 -1.064714427 1.369853167 #&gt; [7] 0.840580629 0.008305848 -1.039757563 -0.465364751 ifelse(x &gt; 0, x, -x) #&gt; [1] 1.245047959 0.990818114 1.115016423 0.275096014 1.064714427 1.369853167 0.840580629 #&gt; [8] 0.008305848 1.039757563 0.465364751 Beware with ifelse() (learn more there), for example ifelse(FALSE, 0, 1:5) #&gt; [1] 1 `if`(FALSE, 0, 1:5) #&gt; [1] 1 2 3 4 5 3.4.5 Exercises Use sample(), rep_len() and split() to make a function that randomly splits some indices in a list of K groups of indices. [Which are the special cases that you should consider?] advr38pkg::split_ind(1:40, 3) #&gt; $`1` #&gt; [1] 1 3 9 13 16 18 22 24 27 28 30 38 39 40 #&gt; #&gt; $`2` #&gt; [1] 5 7 11 12 19 20 26 29 31 32 33 34 35 #&gt; #&gt; $`3` #&gt; [1] 2 4 6 8 10 14 15 17 21 23 25 36 37 Use replicate() and sample() to get a 95% confidence interval for the mean of the following vector: set.seed(1) (x &lt;- rnorm(10)) #&gt; [1] -0.6264538 0.1836433 -0.8356286 1.5952808 0.3295078 -0.8204684 0.4874291 #&gt; [8] 0.7383247 0.5757814 -0.3053884 mean(x) #&gt; [1] 0.1322028 #&gt; 2.5% 97.5% #&gt; -0.3150315 0.5994491 Use match() and some accessor to add a column “my_val” to this data my_mtcars by putting the corresponding value of the column specified in “my_col”. [Can your solution be used for any number of column names?] my_mtcars &lt;- mtcars[c(&quot;mpg&quot;, &quot;hp&quot;)] my_mtcars$my_col &lt;- sample(c(&quot;mpg&quot;, &quot;hp&quot;), size = nrow(my_mtcars), replace = TRUE) head(my_mtcars) #&gt; mpg hp my_col #&gt; Mazda RX4 21.0 110 mpg #&gt; Mazda RX4 Wag 21.0 110 hp #&gt; Datsun 710 22.8 93 hp #&gt; Hornet 4 Drive 21.4 110 mpg #&gt; Hornet Sportabout 18.7 175 hp #&gt; Valiant 18.1 105 mpg Expected result (head): #&gt; mpg hp my_col my_val #&gt; Mazda RX4 21.0 110 mpg 21.0 #&gt; Mazda RX4 Wag 21.0 110 hp 110 #&gt; Datsun 710 22.8 93 hp 93 #&gt; Hornet 4 Drive 21.4 110 mpg 21.4 #&gt; Hornet Sportabout 18.7 175 hp 175 #&gt; Valiant 18.1 105 mpg 18.1 In the following data frame (recall that it is also a list), for the first 3 columns, replace letters by corresponding numbers based on the code: df &lt;- data.frame( id1 = c(&quot;a&quot;, &quot;f&quot;, &quot;a&quot;), id2 = c(&quot;b&quot;, &quot;e&quot;, &quot;e&quot;), id3 = c(&quot;c&quot;, &quot;d&quot;, &quot;f&quot;), inter = c(7.343, 2.454, 3.234), stringsAsFactors = FALSE ) df #&gt; id1 id2 id3 inter #&gt; 1 a b c 7.343 #&gt; 2 f e d 2.454 #&gt; 3 a e f 3.234 (code &lt;- setNames(1:6, letters[1:6])) #&gt; a b c d e f #&gt; 1 2 3 4 5 6 Expected result: #&gt; id1 id2 id3 inter #&gt; 1 1 2 3 7.343 #&gt; 2 6 5 4 2.454 #&gt; 3 1 5 6 3.234 3.5 Environments and scoping Lexical scoping determines where to look for values, not when to look for them. R looks for values when the function is run, not when it’s created. This means that the output of a function can be different depending on objects outside its environment: h &lt;- function() { x &lt;- 10 g &lt;- function() { f &lt;- function() { x + 1 } print(environment(f)) print(ls(environment(f))) ## list the objects in the environment print(parent.env(environment(f))) ## environment(g) f() } print(environment(g)) print(ls(environment(g))) print(parent.env(environment(g))) g() } x &lt;- 100 h() #&gt; &lt;environment: 0x629fc20&gt; #&gt; [1] &quot;g&quot; &quot;x&quot; #&gt; &lt;environment: R_GlobalEnv&gt; #&gt; &lt;environment: 0x6276248&gt; #&gt; [1] &quot;f&quot; #&gt; &lt;environment: 0x629fc20&gt; #&gt; [1] 11 Variable x is not defined inside f so R will look at the environment of f (where f was defined) and then at the parent environment, and so on. Here, the first x that is found has value 10. Be aware that for functions, packages environments are checked last so that you can redefine functions without noticing. c &lt;- function(...) paste0(...) c(1, 2, 3) #&gt; [1] &quot;123&quot; base::c(1, 2, 3) ## you need to explicit the package #&gt; [1] 1 2 3 rm(c) ## remove the new function from the environment c(1, 2, 3) #&gt; [1] 1 2 3 You can use the &lt;&lt;- operator to change the value of an object in an upper environment: count1 &lt;- 0 count2 &lt;- 0 f &lt;- function(i) { count1 &lt;- count1 + 1 ## will assign a new (temporary) count1 count2 &lt;&lt;- count2 + 1 ## will assign count2 on top i + 1 } sapply(1:10, f) #&gt; [1] 2 3 4 5 6 7 8 9 10 11 count1 #&gt; [1] 0 count2 #&gt; [1] 10 Finally, how works the ...? Basically, you copy and paste what is put in ...: f1 &lt;- function(...) { list(...) } f1(a = 2, b = 3) #&gt; $a #&gt; [1] 2 #&gt; #&gt; $b #&gt; [1] 3 list(a = 2, b = 3) #&gt; $a #&gt; [1] 2 #&gt; #&gt; $b #&gt; [1] 3 Learn more about functions and scoping rules of R with the R Programming for Data Science book. 3.6 Attributes and classes Attributes are metadata associated with an object. You can get/set the list of attributes with attributes() or one particular attribute with attr(). attributes(iris) #&gt; $names #&gt; [1] &quot;Sepal.Length&quot; &quot;Sepal.Width&quot; &quot;Petal.Length&quot; &quot;Petal.Width&quot; &quot;Species&quot; #&gt; #&gt; $row.names #&gt; [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #&gt; [22] 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #&gt; [43] 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #&gt; [64] 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 #&gt; [85] 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 #&gt; [106] 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 #&gt; [127] 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 #&gt; [148] 148 149 150 #&gt; #&gt; $class #&gt; [1] &quot;data.frame&quot; class(iris) #&gt; [1] &quot;data.frame&quot; attr(iris, &quot;row.names&quot;) #&gt; [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #&gt; [22] 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #&gt; [43] 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #&gt; [64] 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 #&gt; [85] 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 #&gt; [106] 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 #&gt; [127] 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 #&gt; [148] 148 149 150 You can use structure() to create an object and add some arbitrary attributes. structure(1:10, my_fancy_attribute = &quot;blabla&quot;) #&gt; [1] 1 2 3 4 5 6 7 8 9 10 #&gt; attr(,&quot;my_fancy_attribute&quot;) #&gt; [1] &quot;blabla&quot; There are also some attributes with specific accessor functions to get and set values. For example, use names(x), dim(x) and class(x) instead of attr(x, &quot;names&quot;), attr(x, &quot;dim&quot;) and attr(x, &quot;class&quot;). class(mylm &lt;- lm(Sepal.Length ~ ., data = iris)) #&gt; [1] &quot;lm&quot; I’ve just fitted a linear model in order to predict the sepal length variable of the iris dataset based on the other variables. Using lm() gets me an object of class lm. What are the methods I can use for this object? methods(class = class(mylm)) #&gt; [1] add1 alias anova case.names coerce #&gt; [6] confint cooks.distance deviance dfbeta dfbetas #&gt; [11] drop1 dummy.coef effects extractAIC family #&gt; [16] formula hatvalues influence initialize kappa #&gt; [21] labels logLik model.frame model.matrix nobs #&gt; [26] plot predict print proj qr #&gt; [31] residuals rstandard rstudent show simulate #&gt; [36] slotsFromS3 summary variable.names vcov #&gt; see &#39;?methods&#39; for accessing help and source code summary(mylm) #&gt; #&gt; Call: #&gt; lm(formula = Sepal.Length ~ ., data = iris) #&gt; #&gt; Residuals: #&gt; Min 1Q Median 3Q Max #&gt; -0.79424 -0.21874 0.00899 0.20255 0.73103 #&gt; #&gt; Coefficients: #&gt; Estimate Std. Error t value Pr(&gt;|t|) #&gt; (Intercept) 2.17127 0.27979 7.760 1.43e-12 *** #&gt; Sepal.Width 0.49589 0.08607 5.761 4.87e-08 *** #&gt; Petal.Length 0.82924 0.06853 12.101 &lt; 2e-16 *** #&gt; Petal.Width -0.31516 0.15120 -2.084 0.03889 * #&gt; Speciesversicolor -0.72356 0.24017 -3.013 0.00306 ** #&gt; Speciesvirginica -1.02350 0.33373 -3.067 0.00258 ** #&gt; --- #&gt; Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 #&gt; #&gt; Residual standard error: 0.3068 on 144 degrees of freedom #&gt; Multiple R-squared: 0.8673, Adjusted R-squared: 0.8627 #&gt; F-statistic: 188.3 on 5 and 144 DF, p-value: &lt; 2.2e-16 plot(mylm) R has the easiest way to create a class and to use methods on objects of this class; it is called S3. If you want to know more about the other types of classes, see the Advanced R book. agent007 &lt;- list(first = &quot;James&quot;, last = &quot;Bond&quot;) agent007 #&gt; $first #&gt; [1] &quot;James&quot; #&gt; #&gt; $last #&gt; [1] &quot;Bond&quot; class(agent007) &lt;- &quot;Person&quot; ## &quot;agent007&quot; is now an object of class &quot;Person&quot; # Just make a function called &lt;method_name&gt;.&lt;class_name&gt;() print.Person &lt;- function(x) { print(glue::glue(&quot;My name is {x$last}, {x$first} {x$last}.&quot;)) invisible(x) } agent007 #&gt; My name is Bond, James Bond. # Constructor of class as simple function Person &lt;- function(first, last) { structure(list(first = first, last = last), class = &quot;Person&quot;) } (me &lt;- Person(&quot;Florian&quot;, &quot;Privé&quot;)) #&gt; My name is Privé, Florian Privé. An object can have many classes: Worker &lt;- function(first, last, job) { obj &lt;- Person(first, last) obj$job &lt;- job class(obj) &lt;- c(&quot;Worker&quot;, class(obj)) obj } print.Worker &lt;- function(x) { print.Person(x) print(glue::glue(&quot;I am a {x$job}.&quot;)) invisible(x) } (worker_007 &lt;- Worker(&quot;James&quot;, &quot;Bond&quot;, &quot;secret agent&quot;)) #&gt; My name is Bond, James Bond. #&gt; I am a secret agent. (worker_me &lt;- Worker(&quot;Florian&quot;, &quot;Privé&quot;, &quot;PhD student&quot;)) #&gt; My name is Privé, Florian Privé. #&gt; I am a PhD student. "]
]
